<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSAPP-2-信息的表示和处理</title>
      <link href="/2019/09/14/csapp/csapp-2-xin-xi-de-biao-shi-he-chu-li/"/>
      <url>/2019/09/14/csapp/csapp-2-xin-xi-de-biao-shi-he-chu-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果能完全理解计算机系统以及它对应用程序的影响，那么恭喜你，你走上了一条为数不多的大牛道路。</p></blockquote><p>本文是深入理解计算机系统的第二篇文章，接着上一篇我们讲解的计算机系统开篇-<a href="http://mp.weixin.qq.com/s?__biz=MzA4MTE4NTg1OA==&amp;mid=2247483654&amp;idx=1&amp;sn=25c528de5f245a65a27aa0b261382ca7&amp;chksm=9f999c2ba8ee153d79beb9db613c2f13594966c713ec889c1ade9463baf663b0e7fbb40e921a&amp;token=1690272020&amp;lang=zh_CN#rd" target="_blank" rel="noopener">《计算机系统漫游》</a>，本篇文章继续深入，一起来学习 <strong>信息的表示和处理</strong>。</p><p>本篇文章一共分为四部分，<strong>信息存储</strong>、<strong>整数的表示</strong>，<strong>整数的运算</strong> 和 <strong>浮点数</strong>。</p><h2 id="1-信息存储"><a href="#1-信息存储" class="headerlink" title="1. 信息存储"></a>1. 信息存储</h2><p>程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存</strong>。内存中的每一个字节都由一个唯一的数字来标识，称为它的<strong>地址</strong>，地址的集合就称为<strong>虚拟地址空间</strong>。</p><blockquote><p>每台计算都有一个字长，虚拟地址空间是以字来编码的，所以字长决定了虚拟地址空间的大小。对于一个字长为 w 位的机器而言，虚拟地址的范围为 0~$2^w$ -1 ,程序最多访问$2^w$ 个字节。</p></blockquote><h3 id="1-1-寻址和字节顺序"><a href="#1-1-寻址和字节顺序" class="headerlink" title="1.1 寻址和字节顺序"></a>1.1 寻址和字节顺序</h3><p>对于我们日常程序中的对象，它们在内存中往往是多字节的，那么我们必须知道两个规则：<strong>这个对象的地址是什么？</strong>以及<strong>内存中如何排列这些字节？</strong></p><p>在几乎所有的机器上，字节都是被连续存储的，对象的地址为所使用字节中最小的地址。例如，一个int类型的变量x的地址为0x100，也就是地址表达式&amp;x 的值为0x100，x的四个字节存储在内存0x100、0x101、0x102、0x103位置。</p><p>排列表示一个对象的字节，有两个通用的规则：</p><ul><li>大端法：最高有效字节在最前面</li><li>小端法：最低有效字节在最前面</li></ul><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/3dp1r.png" alt=""></p><p>对于我们程序员来说，机器使用的字节顺序对我们是不可见的，无论哪种字节顺序的机器，我们的程序编译后得到的结果都是一样的，不过有时候字节顺序也会成为问题，这里不再详述什么情况下会产生问题，只作学习验证机器的字节顺序不同产生的不同结果。</p><pre class=" language-c"><code class="language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>byte_pointer<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">show_bytes</span><span class="token punctuation">(</span>byte_pointer start<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2x"</span><span class="token punctuation">,</span>start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">show_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">show_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">show_float</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">show_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">show_pointer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">show_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test_show_bytes</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ival <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token keyword">float</span> fval <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> ival<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pval <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span>    <span class="token function">show_int</span><span class="token punctuation">(</span>ival<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">show_float</span><span class="token punctuation">(</span>fval<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">show_pointer</span><span class="token punctuation">(</span>pval<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">test_show_bytes</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行上面的c语言程序，得到的结果如下：</p><p>39300000<br>00e44046<br>a8e7a4c2ff7f0000</p><p>参数12345的十六进制表示为0x00000393,结合上面的结果 39300000 说明我的linux64是一个小端法机器。下面在放一张在各个机器测试的不同结果，更加全面的对比图：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/2gzok.png" alt=""></p><p>上图指针值完全不相同的原因是不同的操作系统使用不同的存储分配规则，不过需要注意的是Linux64使用的是8字节地址。</p><h3 id="1-2-表示字符串"><a href="#1-2-表示字符串" class="headerlink" title="1.2 表示字符串"></a>1.2 表示字符串</h3><p>C语言的字符串：一个以null(值为0)字符结尾的字符数组 如字符串”12345”编码为 61 62 63 64 65 使用ASCII编码。 linux系统可以使用 man ascii 命令查看ASCII编码表。</p><h3 id="1-3-布尔代数简介"><a href="#1-3-布尔代数简介" class="headerlink" title="1.3 布尔代数简介"></a>1.3 布尔代数简介</h3><p>二进制是计算机编码、存储和操作信息的核心。 将逻辑值 TRUE 和 FALSE 编码为1和0，能够设计一种代数，用来研究逻辑推理的基本原则。</p><p>布尔运算：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/o8eeg.png" alt=""></p><h3 id="1-4-C语言中的位级运算"><a href="#1-4-C语言中的位级运算" class="headerlink" title="1.4 C语言中的位级运算"></a>1.4 C语言中的位级运算</h3><blockquote><p>事实上，我们平时代码中写的 | 就是OR(或)，&amp; 就是AND(与)，~ 就是NOT（取反），^就是异或，本质上都是按位进行运算的。</p></blockquote><p>以下是一些对char数据类型表达式求值的例子：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/5z9tg.png" alt=""></p><p>正如示例说明的那样，确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。</p><h3 id="1-5-C语言中的移位运算"><a href="#1-5-C语言中的移位运算" class="headerlink" title="1.5 C语言中的移位运算"></a>1.5 C语言中的移位运算</h3><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/yc32u.png" alt=""></p><p>移位运算右移分为：逻辑右移和算术右移。</p><ul><li>逻辑右移：在左端补0；</li><li>算术右移：如果操作数的最高位是1则左端补1，如果为0则补0；</li></ul><p>C语言中，几乎所有的编译器都对有符号数使用算术右移，无符号数使用逻辑右移。</p><p>Java中有明确定义，x&gt;&gt;k 表示算术右移k个位置，而x&gt;&gt;&gt;k 会对x做逻辑右移。</p><p>这里说明一个移位运算有关的操作符优先级问题：</p><p>表达式 1&lt;&lt;2+3&lt;&lt;4 ，本意是（1&lt;&lt;2）+(3&lt;&lt;4),你可能也会犯这样的错误，其实前面的表达式等价于：1&lt;&lt;(2+3)&lt;&lt;4,因为<strong>加法（减法）的优先级比移位运算要高</strong>。</p><h2 id="2-整数表示"><a href="#2-整数表示" class="headerlink" title="2. 整数表示"></a>2. 整数表示</h2><p>下面的数据术语用来精确定义和描述计算机如何编码和操作整数。</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/5y3sx.png" alt=""></p><h3 id="2-1-无符号数的编码"><a href="#2-1-无符号数的编码" class="headerlink" title="2.1 无符号数的编码"></a>2.1 无符号数的编码</h3><p>假设一个整数有w位，每个位的取值即0非1。</p><p><strong>原理：无符号数编码的定义</strong></p><p>对向量<br>$$<br>\vec{x}=\left[\begin{array}{cccc}{x_{w-1},} &amp; {x_{w-2}} &amp; {,} &amp; {\cdots, \quad x_{0}}\end{array}\right]<br>$$<br>用一个函数来表示：<br>$$<br>B 2 U_{w}(\vec{x}) \doteq \sum_{i=0}^{w-1} x_{i} 2^{i}<br>$$<br>计算规则：<br>$$<br>\begin{array}{l}{B 2 U_{4}([0001])=0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+0+0+1=1} \ {B 2 U_{4}([0101])=0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+4+0+1=5} \ {B 2 U_{4}([1011])=1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=8+0+2+1=11} \ {B 2 U_{4}([1111])=1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=8+4+2+1=15}\end{array}<br>$$</p><h3 id="2-2-补码编码"><a href="#2-2-补码编码" class="headerlink" title="2.2 补码编码"></a>2.2 补码编码</h3><p>上面介绍的是无符号编码的表示形式，但是我们应用中，还是希望表示负数值。最常见的有符号数计算机表示方式就是补码。</p><p><strong>原理：补码编码的定义</strong></p><p>对向量：<br>$$<br>\begin{aligned} \vec{x}=\left[x_{w-1}, x_{w-2},\right.&amp;\left.\cdots, x_{0}\right] \ &amp; B 2 T_{w}(\vec{x}) \doteq-x_{u-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i} \end{aligned}<br>$$</p><p>最高有效位即 $x_{w-1}$ 也称为符号位。符号位等于1时，表示值为负，等于0时，值为非负，下面来看实际的计算示例：</p><p>$$\begin{array}{l}{B 2 T_{4}([0001])=-0 \cdot 2^{3}+0 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+0+0+1=1} \ {B 2 T_{4}([0101])=-0 \cdot 2^{3}+1 \cdot 2^{2}+0 \cdot 2^{1}+1 \cdot 2^{0}=0+4+0+1=5} \ {B 2 T_{4}([1011])=-1 \cdot 2^{3}+0 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=-8+0+2+1=-5} \ {B 2 T_{4}([1111])=-1 \cdot 2^{3}+1 \cdot 2^{2}+1 \cdot 2^{1}+1 \cdot 2^{0}=-8+4+2+1=-1}\end{array}$$</p><p>这里让我们一起来考虑下补码所能表示的值的范围，最小值为：$T M i n_{w} \doteq-2^{w-1}$.</p><p>最大值为：$T M a x_{w} \doteq \sum_{i=0}^{w-2} 2^{i}=2^{w-1}-1$</p><p>例如以长度为4为例，$T M i n_{4}=B 2 T_{4}([1000])=-2^{3}=-8$, 而 $T M a x_{4}=B 2 T_{4}([0111])=2^{2}+2^{1}+2^{0}=4+2+1=7$</p><p>补码编码也是取值范围内每个数字都有唯一的w位补码编码。</p><h3 id="2-3-有符号数和无符号数之间的转换"><a href="#2-3-有符号数和无符号数之间的转换" class="headerlink" title="2.3 有符号数和无符号数之间的转换"></a>2.3 有符号数和无符号数之间的转换</h3><p><strong>原理：补码转换为无符号数</strong></p><p>对满足$T M i n_{w} \leqslant x \leqslant T M a x_{w}$ 的 x 有：<br>$$<br>T 2 U_{w}(x)=\left{\begin{array}{ll}{x+2^{w},} &amp; {x&lt;0} \ {x,} &amp; {x \geqslant 0}\end{array}\right.<br>$$</p><p>比如，$T 2 U_{16}(-12345)=-12345+2^{16}=53191$ ,同时 $T 2 U_{w}(-1)=-1+2^{w}=U M a x_{w}$。</p><p><strong>原理：无符号数转换为补码</strong></p><p>对满足 $0 \leqslant u \leqslant U M a x_{w}$ 的 u 有：<br>$$<br>U 2 T_{w}(u)=\left{\begin{array}{ll}{u,} &amp; {u \leqslant T \operatorname{Max}<em>{w}} \ {u-2^{w},} &amp; {u&gt;\operatorname{TMax}</em>{w}}\end{array}\right.<br>$$</p><h2 id="3-整数运算"><a href="#3-整数运算" class="headerlink" title="3. 整数运算"></a>3. 整数运算</h2><p>在我们刚刚学习计算机时，大家有没有经历过，两个正数相加会得出一个负数，而比较表达式 x&lt;y 和 x-y&lt;0 会产生不同的结果呢？带着这些问题一起往下看吧。</p><h3 id="3-1-无符号加法"><a href="#3-1-无符号加法" class="headerlink" title="3.1 无符号加法"></a>3.1 无符号加法</h3><p><strong>原理：无符号加法，对满足</strong> $0 \leqslant x, \quad y&lt;2^{w}$  的 x 和 y有：<br>$$<br>x+_{w}^{u} y=\left{\begin{array}{ll}{x+y,} &amp; {x+y&lt;2^{w}} \ {x+y-2^{w},} &amp; {2^{w} \leqslant  x+y&lt;2^{w+1}}\end{array}\right.<br>$$</p><p>比如：x=9，y=12 的位表示分别为[1001] 和 [1100]。它们的和是21，表示为5位的[10101]，产生溢出，丢弃最高位。 </p><p><strong>原理： 检测无符号数加法中的溢出</strong></p><p>对在范围 $0 \leqslant x, \quad y \leqslant U M a x_{w}$,s=x+y，若s &lt; x 或者等价的 s &lt; y时，发生了溢出。</p><p><strong>原理： 无符号数求反</strong></p><p>对满足 $0 \leqslant x&lt;2^{w}$ ,的任意x，其w位的无符号逆元 $-_{w}^{u} x$ 表达式如下：</p><p>$-_{w}^{u} x=\left{\begin{array}{ll}{x,} &amp; {x=0} \ {2^{w}-x,} &amp; {x&gt;0}\end{array}\right.$</p><h3 id="3-2-补码加法"><a href="#3-2-补码加法" class="headerlink" title="3.2 补码加法"></a>3.2 补码加法</h3><p><strong>原理： 补码加法</strong></p><p>对满足$0 \leqslant x, \quad y \leqslant U M a x_{w}$ 的整数x，y，有：</p><p>$$<br>x+_{w}^{t} y=\left{\begin{array}{ll}{x+y-2^{w},} &amp; {2^{w-1} \leqslant x+y}  \ {x+y,} &amp; {-2^{w-1} \leqslant x+y&lt;2^{w-1} \quad \begin{array}{l}\ \end{array}} \ {x+y+2^{w},} &amp; {x+y&lt;-2^{w-1}} \end{array}\right.<br>$$</p><p><strong>原理： 检测补码加法中的溢出</strong></p><p>对满足 $T M i n_{w} \leqslant x, \quad y \leqslant T M a x_{w}$ 的x 和 y，令 s = x + y。当且仅当x&gt;0,y&gt;0，但s&lt;=0时，计算s发生了正溢出。当且仅当 x&lt;0,y&lt;0，但s&gt;=0时，计算发生了负溢出。</p><h3 id="3-3-乘法和除法"><a href="#3-3-乘法和除法" class="headerlink" title="3.3 乘法和除法"></a>3.3 乘法和除法</h3><p>在大多数机器上，整数乘法指令相当慢，需要10个或者更多的时钟周期，然而<strong>加法、减法、位运算、移位操作只需要一个时钟周期</strong>。</p><p>因此，编译器使用了移位和加法运算的组合代替乘以常数因子的乘法。</p><p><strong>原理： 乘以2的幂</strong></p><p>例如：x*14，利用14 = $14=2^{3}+2^{2}+2^{1}$ ,编译器会将乘法重写为 $(x&lt;&lt;3)+(x&lt;2)+(x&lt;&lt;1)$ ,将乘法替换为三个移位和一个加法。</p><p>在大多数机器上，整数除法比乘法更慢，需要30个左右的时钟周期。</p><p>所以除法，也可以采用移位运算，相对于乘法这里采用的是右移，而不是左移。</p><h2 id="4-浮点数"><a href="#4-浮点数" class="headerlink" title="4. 浮点数"></a>4. 浮点数</h2><blockquote><p>固定范围的数字，小数点前代表大小范围，小数点后代表精度，浮动小数点即平衡范围和精度，所以叫浮点数</p></blockquote><h3 id="4-1-二进制小数"><a href="#4-1-二进制小数" class="headerlink" title="4.1 二进制小数"></a>4.1 二进制小数</h3><p>十进制数转换描述定义：<br>$$<br>d=\sum_{i=-n}^{m} 10^{i} \times d_{i}<br>$$</p><p>例如：12.34 = $1 \times 10^{1}+2 \times 10^{0}+3 \times 10^{-1}+4 \times 10^{-2}=12 \frac{34}{100}$</p><p>二进制数转换描述定义：<br>$$<br>b=\sum_{i=-n}^{m} 2^{i} \times b_{i}<br>$$</p><p>例如，$101.11_{2}= 1 \times 2^{2}+0 \times 2^{1}+1 \times 2^{0}+1 \times 2^{-1}+1 \times 2^{-2}=4+0+1+\frac{1}{2}+\frac{1}{4}=5 \frac{3}{4} $</p><p>增加二进制表示的长度可以提高表示的精度：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/4aene.png" alt=""></p><h3 id="4-2-IEEE浮点表示"><a href="#4-2-IEEE浮点表示" class="headerlink" title="4.2 IEEE浮点表示"></a>4.2 IEEE浮点表示</h3><p>IEEE浮点标准用 $V=(-1)^{s} \times M \times 2^{E}$ 的形式来表示一个数：</p><ul><li>符号（sign）s决定这数是负数（s=1）还是正数（s=0）。</li><li>尾数（signnificand） M是一个二进制小数，它的范围是 $1 \sim 2-\varepsilon$。</li><li>阶码（exponent） E的作用是对浮点数加权，权重是2的E次幂。</li><li>一个单独的符号位s</li><li>k位的阶码字段 编码阶码E</li><li>n位小数字段 编码尾数M</li></ul><p>如下图：</p><p>在单精度格式（float），s，exp 和 frac 字段分别为 s=1，k=8, n = 23,得到一个32位的表示。</p><p>在双精度浮点格式（double）中，s=1、k=11、n=52位，得到一个64位的表示。</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/vw19h.png" alt=""></p><h3 id="4-3-C语言中的浮点数"><a href="#4-3-C语言中的浮点数" class="headerlink" title="4.3 C语言中的浮点数"></a>4.3 C语言中的浮点数</h3><ul><li>从int转换成float，数字不会溢出，但可能会被舍入；</li><li>从int或float转成double，因为double范围更大，精度更高，所以能够精确的保留数值；</li><li>从double转成float，因为范围要小，所以值可能溢出成正无穷或者负无穷，另外由于精度较小，可能舍入。</li><li>从float或者double转成int，值将会向零舍入，例如1.999转换成1，-1.999转成-1。进一步来说，值可能会溢出。</li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul><li>计算机将信息编码为位（比特），通常组成成字节序列。</li><li>大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。在位级上理解这些编码有助于写出全部数值范围上正确运算的程序。</li><li>由于编码长度有限，计算机运算会产生溢出。</li><li>使用浮点运算要小心，因为只有有限的范围和精度。</li></ul><blockquote><p>本文涉及的数学知识较多，看着比较枯燥。如果是计算机专业的同学，应该会有些熟悉。 不过我们如果要做一名高级程序员，计算机底层是绕不过去的，所以还是撸起袖子，加油干吧！</p></blockquote><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTE4NTg1OA==&amp;mid=2247483654&amp;idx=1&amp;sn=25c528de5f245a65a27aa0b261382ca7&amp;chksm=9f999c2ba8ee153d79beb9db613c2f13594966c713ec889c1ade9463baf663b0e7fbb40e921a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">计算机系统漫游</a></li></ul><p>​        </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chapter6-网络安全</title>
      <link href="/2019/09/14/ji-suan-ji-wang-luo/chapter6-wang-luo-an-quan/"/>
      <url>/2019/09/14/ji-suan-ji-wang-luo/chapter6-wang-luo-an-quan/</url>
      
        <content type="html"><![CDATA[<p>计算机网络中的两个节点希望安全通信，需要具有以下的特性</p><ul><li><strong>机密性</strong>。这说明通信的内容只有发送方和接收方才能知道，窃听者截获报文后也无法理解报文的内容</li><li><strong>报文完整性</strong>。发送方和接收方希望报文在传输过程中没有被篡改</li><li><strong>端点鉴别</strong>。发送方和接收方都能确定另一方的确有其声称的身份</li><li><strong>运行安全性</strong>。能够连接到互联网的主机，都希望不会因为恶意者的攻击而瘫痪</li></ul><h2 id="密码学原理"><a href="#密码学原理" class="headerlink" title="密码学原理"></a>密码学原理</h2><p>要达到安全通信中的机密性，就需要对传输的报文加密。被加密的报文称为 <strong>明文（plaintext，clear text）</strong>；使用 <strong>加密算法（encryption algorithm）</strong> 可以加密明文得到 <strong>密文（ciphertext）</strong>；在加密的过程中需要使用 <strong>密钥（key）</strong>；如果需要把密文重新转成明文，就需要用到 <strong>解密算法（decryption algorithm）</strong>；类似的，解密算法也需要解密密钥。在对称加密中，加密密钥和解密密钥是相同的；而在公开密钥系统中，加密和解密的密钥是不同的，且加密密钥是公开的</p><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>凯撒密码是以罗马共和国执政官尤里乌斯·凯撒的名字命名的一种加密技术，原理非常简单：对于一个明文输入，将明文中的字母替换成另一个字母。每一种替换规则就是一个密钥</p><p>凯撒密码有一个重要缺陷，即相同的明文字母对应同一个密文字母，因此可以用统计分析的方式去破解密码。比如英文中字母 e 出现的频率大约是 13%，而字母 t 出现的频率是 19%，而且英文单词 the 出现的概率也特别高，这样就能统计密文中字母或单词出现的频率来估算加密的密钥</p><p>如果尝试攻击凯撒密码，根据攻击者所拥有的信息，可以把攻击方法分为下面 3 种</p><ul><li><strong>唯密文攻击</strong>：攻击者只知道密文，这时可以使用对字母频率的统计分析来攻击凯撒密码</li><li><strong>已知明文攻击</strong>：攻击者知道明文中一定会出现一些单词，根据这些单词的密文来攻击凯撒密码</li><li><strong>选择明文攻击</strong>：攻击者能够得到一些明文对应的密文，从而展开攻击。这与已知明文攻击有些类似</li></ul><p>针对这几种攻击，后来发展出了 <strong>多码代替密码（polyalphabetic encryption）</strong> 技术，这种技术尝试用多个凯撒密码密钥去加密一段密文</p><h3 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h3><p><strong>块密码</strong> 是对称加密的一种方法，它将明文分为 k 比特的块，将每一个块映射为另一个块，映射的结果就是密文，每一种映射就是一个密钥。对于 k 比特的块，共有 <code>(2^k)!</code> 种密钥。当 k 的值比较大时（如 k = 64），保存 <code>(2^k)!</code> 个映射关系的成本太高了，因此实际应用中会使用函数模拟的方式生成随机排列表，使得输入一个 k 比特的明文得到 k 比特密文，这个函数必须要有一个性质：明文的每一个比特位都能影响输出结果</p><p>目前 DES（Data Encryption Standard）、3DES 和 AES（Advanced Encryption Standard）都是块密码</p><p>实际上块密码与凯撒密码有些相似的地方，他们都是把明文替换成密文的方式，因此也会具有与凯撒密码相同的弱点，即相同的明文得到相同的密文。消除这个弱点的方式是在加密的过程中引入随机性。</p><p>一个可行的方法是：将明文分为 k 比特的明文快，对于每个明文快 mi，产生一个随机的 k 比特块 ri，那么密文 <code>ci = Ks(mi xor ri)</code>，其中 xor 是异或操作，Ks 是以 s 为密钥的加密函数。由于每一个明文快对应的随机块 ri 是不一样的，因此相同的明文块会产生不同的密文块</p><p>这个方法也有一个问题：传输的数据量变成了原来的两倍。因为现在不仅仅需要传输密文，还需要传输随机块 ri。为了解决这个问题，产生了一种称作 <strong>密码块链接（Cipher Block Chaining，CBC）</strong> 的技术。它的原理是：仅仅产生第一个明文块的随机块，加密得到第一个密文块后，这个密文块就作为下一个明文块的随机块。</p><h2 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h2><p>上面的凯撒密码和块密码都是被称为对称加密的技术，这意味着加密方和解密方需要使用同一个密钥来加密和解密。对称加密引入了一个新的问题：双方该如何安全的共享密钥。在现代的计算机网络中，发送方和接收方是无法在线下见面并确定密钥的</p><p>为了解决这个问题，一种被称为 <strong>公开密钥加密</strong> 的技术被发明出来。公开密钥加密技术使用两个密钥，一个被称为 <strong>公钥（public key）</strong>，一个被称为 <strong>私钥（private key）</strong>。公钥是公开的，并且每个人都能知道，而私钥需要保密。公开密钥加密算法有这样一个性质：使用公钥加密明文得到密文，可以使用私钥解密；使用私钥加密明文得到密文，可以使用公钥解密。因此当两个人，比如 Bob 和 Alice 想要通信时，Bob 先获取到 Alice 的公钥，使用公钥加密后把密文发送给 Alice，Alice 得到密文后就能用私钥解密得到明文了；同理，Alice 也能获取到 Bob 的公钥并加密明文，Bob 用自己的私钥解密。当攻击者截取到密文后，因为没有私钥，也就不能解密密文了。</p><p>公开密钥加密算法需要面临两个问题</p><ol><li>攻击者可以使用选择明文攻击。因为公钥和加密算法是众所周知的，攻击者可以用任意明文生成密文，并以此展开攻击，公开密钥加密必须能防止攻击者以猜出私钥</li><li>接收方无法得知密文是谁发送的。在共享密钥中，接收方收到密文后就能知道发送方是谁了，因为只有发送方能有密钥去加密。现在因为公钥和加密算法是公开的，任何一个人都能向接收方发送一段密文，因此接收方必须使用其他方法去确定发送方的身份</li></ol><p>RSA 是现在比较流行的公开密钥加密算法，它基于的原理是目前没有高效的算法可以对大整数做因数分解。它的工作方式我就不说了，因为我也看不懂</p><h2 id="报文完整性和数字签名"><a href="#报文完整性和数字签名" class="headerlink" title="报文完整性和数字签名"></a>报文完整性和数字签名</h2><p>Bob 在收到一个来自于声称自己是 Alice 的人的报文时，他需要做下面两件事</p><ol><li>确定报文确实来自于 Alice</li><li>确定报文在传输过程中没有收到篡改</li></ol><p>在讨论这两点之前，我们还需要学习有关 <strong>密码散列函数</strong> 的知识</p><h3 id="密码散列函数"><a href="#密码散列函数" class="headerlink" title="密码散列函数"></a>密码散列函数</h3><p>密码散列函数以 m 作为输入，可以得到一个固定长度的输出字符串，而且必须要求找到任意两个不同的报文 x 和 y，计算 H(x) = H(y) 在计算上是不可能的，这也表明，得到散列函数的输出后，反推输入是不可能的。目前常用的散列函数有 MD5、SHA-1</p><p>有了散列函数，就能在接收端鉴定报文在传输过程中有没有被篡改了。比如 Alice 向 Bob 发送报文</p><ol><li>Alice 和 Bob 之间先生成一个 <strong>鉴别密钥（authentication key）</strong> s</li><li>Alice 生成报文 m，使用散列函数计算得到 H(m + s)，H(m+s) 也叫做 <strong>报文鉴别码（Message Authentication Code，MAC）</strong></li><li>Alice 把 m 和 H(m + s) 合并成扩展报文 (m, H(m + s)) 发送给 Bob</li><li>Bob 收到扩展报文后，同样去计算 H(m + s)，如果与收到的 MAC 一致，说明报文没有被篡改</li></ol><p>鉴别密钥的作用是防止中间人在捕获到报文 m 后，篡改报文并重名生成 H(m)，这样接收方就还是无法确定报文是否被篡改</p><p>目前最流行的 MAC 标准是 HMAC</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是一种同时使用了散列函数和非对称加密的技术。当 Bob 需要对一个报文 m 做签名，他首先用散列函数对报文计算指纹 H(m)，然后用自己的私钥和指纹作为输入，得到的输出就是数字签名。任何人如果想证明 Bob 的确对报文 m 做过签名，只需要先计算报文的指纹，然后使用 Bob 的公钥对签名进行解密，如果得到的指纹和结果是一致的，就说明了 Bob 的确签署了报文</p><p>上面的数字签名技术还有一个问题没解决：如果为每个人分配私钥和公钥。这个问题需要由 <strong>认证中心（Certification Authority，CA）</strong> 来负责。CA 为每个需要被认证的实体生成一个证书，证书内有公钥、私钥和拥有者的全局唯一标识符，大家只要信任 CA 就能信赖数字签名技术了</p><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><p>PGP 是一个电子邮件加密方案，全称是 Pretty Good Privacy。它融合了 RSA 加密、对称加密、数字签名技术，提供了对电子邮件的机密性、发送方鉴别和保温完整性验证功能，它的基本原理是这样的（假设 Alice 要向 Bob 发送邮件）</p><ol><li>Alice 使用散列函数得到报文摘要</li><li>Alice 使用自己的私钥加密摘要得到报文签名，将数字签名和报文级联成为新报文</li><li>Alice 随机生成一个会话密钥，利用会话密钥加密新报文得到密文，用 Bob 的公钥加密会话密钥</li><li>Alice 将报文签名、密文、加密后的会话密钥发送给 Bob</li></ol><p>到此 Alice 的工作就结束了。Bob 在接收到 Alice 发来的数据后，做如下操作</p><ol><li>Bob 用自己的私钥解密会话密钥</li><li>Bob 用会话密钥解密密文，得到报文和数字签名</li><li>Bob 使用散列函数得到报文摘要，然后使用自己的公钥解密数字签名，如果两个计算得到的结果相同，说明数据在传输过程中没有被篡改</li></ol><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p><strong>SSL(Secure Socket Layer)</strong> 相当于是一个提供了安全服务的加强版 TCP，它的第三版本也被称为 <strong>TLS(Transport Layer Security)</strong> 。SSL 差不多是取代 TCP 原有位置的，但是实际上它是一个应用层协议。SSL 的具体原理也很复杂，我这里只列出一些要点</p><ol><li>在 SSL 通信的双方（比如 Bob 和 Alice）共使用了 4 个密钥：一个密钥是 Bob 向 Alice 发送数据的会话密钥；一个密钥是 Bob 向 Alice 发送报文完整性检测 MAC 密钥；一个密钥是 Alice 向 Bob 发送数据的会话密钥；一个密钥是 Alice 向 Bob 发送报文完整性检测 MAC 密钥</li><li>SSL 将报文数据分成被称为 <strong>记录</strong> 的基本单元，对记录做加密和报文完整性验证。SSL 对记录数据+MAC密钥+记录序号做散列，这样能防止中间人恶意替换记录的顺序</li></ol><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>防火墙是一种软件加上硬件一起实施网络连接管理的工具，可以认为这是一个位于网络边缘的路由器，具有下面的性质</p><ul><li>所有从内部网络流向外部和从外部流向内部的流量都必须经过防火墙</li><li>防火墙仅会让允许授权的流量通过</li><li>防火墙必须足够安全，不能被攻破</li></ul><p>防火墙的过滤方式可以分为 3 类：<strong>传统分组过滤器（traditional packet filter）</strong>、<strong>状态过滤器（stateful filter）</strong>、<strong>应用程序网关（application gateway）</strong></p><h3 id="分组过滤器"><a href="#分组过滤器" class="headerlink" title="分组过滤器"></a>分组过滤器</h3><p>分组过滤器检查所有流经防火墙的数据包，基于事先定下的规则决定是否放行流量。它做出的决定基于下面因素</p><ul><li>数据报的源地址或目的地址</li><li>数据报的协议类型：TCP、UDP、ICMP、OSPF 等</li><li>TCP 或 UDP 的源或目的端口</li><li>TCP 标志比特：SYN、ACK 等</li><li>ICMP 报文类型</li><li>数据报离开和进入网络的不同规则</li><li>对不同路由器的接口的不同规则</li></ul><h3 id="状态分组过滤器"><a href="#状态分组过滤器" class="headerlink" title="状态分组过滤器"></a>状态分组过滤器</h3><p>前面的分组过滤器只是根据一个分组的数据报决定是否放行，而状态分组过滤器会记录这个分组属于的连接，根据连接的状态决定是否放行分组</p><p>简单来说，当内部或者外部用户发起 TCP 连接时，都必须经历 3 次握手（ SYN、SYNACK、ACK），防火墙可以探测到这些报文，然后在自己的数据库包保存这个 TCP 连接信息，当一个数据报来到防火墙时，防火墙在自己的数据库中检索到连接信息，然后根据既定的规则决定是否放行</p><h3 id="应用程序网关"><a href="#应用程序网关" class="headerlink" title="应用程序网关"></a>应用程序网关</h3><p>上面的两个过滤器都是应用于非应用层的数据报，有时候报文的认证信息存在于应用层中，这时候需要使用到 <strong>应用程序网关（applicatin gateway）</strong>。它不仅仅会检查 TCP 或者 UDP 数据报，还会检查应用层数据，以决定流量是否放行</p><h3 id="入侵检测系统"><a href="#入侵检测系统" class="headerlink" title="入侵检测系统"></a>入侵检测系统</h3><p><strong>入侵检测系统（Intrusion Detection System，IDS）</strong> 相当于是一个探针，安装在网络路径上，他会检测所有的流经自身的流量，在其中检测是否存在可疑流量，在必要的时候向网络管理员发送警告</p><p>在一个网络中可能会部署多个 IDS，因为 IDS 对所有流量执行检测，需要大量的计算量，部署多个 IDS 能减轻每个 IDS 的负担</p><p>IDS 使用了 <strong>基于特征的系统（signature-based system）</strong> 或 <strong>基于异常的系统（anomaly-based system）</strong>。基于特征的 IDS 有一个攻击的特征数据库，当流经的流量与某种攻击相似时（源端口相同、或者协议的某些字段值相同），它就会发出警告。基于特征的 IDS 的缺点是不能检测出新的攻击</p><p>基于异常的 IDS 观察流经自身的流量，统计不同协议的分组的数量，当某种分组的数量异常升高时，他就判定网络中可能存在攻击行为。它的优点就是能够检测出新的攻击形式</p><p>Snort 是一个开源的 IDS 实现，在全球大量部署，当一种新的攻击方式出现时，Snort 社区可能会在几小时内编写出应对规则，并供全球范围内的网络管理员下载和部署</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chapter5-链路层</title>
      <link href="/2019/09/14/ji-suan-ji-wang-luo/chapter5-lian-lu-ceng/"/>
      <url>/2019/09/14/ji-suan-ji-wang-luo/chapter5-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<p>本章接着前一章学习的网络层，更加深入来到下一层数据链路层。</p><h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><p>首先来一张数据报传输过程的例子，帮助理解数据报是如何从发送端到达目的端的，中间发生了怎样的过程，来看下面这张图：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jvu78.png" alt="公司网络"></p><p>如上图所示的公司网络中，思考从无线主机向服务器发送一个数据报，该数据报将实际通过6段链路：</p><ol><li>发送主机与WIFI接入点之间的Wifi链路；</li><li>接入点与链路层交换机之间的以太网链路；</li><li>链路层交换机与路由器之间的链路；</li><li>两台路由器之间的链路；</li><li>路由器和服务器链路层交换机之间的链路；</li><li>交换机和服务器之间的以太网链路；</li></ol><p>在通过特定链路时，传输结点将数据报封装在链路层帧中，并将该帧传送到链路中。</p><h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><ol><li>成帧</li><li>链路接入</li><li>可靠交付，链路层的可靠交付通过是通过确认和重传取得，这里应该联想传输层的TCP协议提供的可靠传输服务。</li><li>差错检测和纠正</li></ol><h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><p><strong>链路层的主体部分是在网络适配器</strong>中实现的，也就是我们说的网卡，它实现的服务有：成帧、链路接入、差错检测等。</p><h2 id="差错校验和纠技术"><a href="#差错校验和纠技术" class="headerlink" title="差错校验和纠技术"></a>差错校验和纠技术</h2><p>链路层接到上层的应用数据后，加上自己的首部组成链路层数据报，放在链路中进行传播。传播中可能发生错误，因此需要有差错检测机制来发现链路层首部和应用数据的错误。差错检测可能并不能找到所有的错误，因此链路层可能向上层交付一个有差错的数据报，但是这种事情的发生概率比较低</p><p>差错检测常用的 3 种技术分别是：<strong>奇偶校验、检验和方法、循环冗余检测</strong></p><ol><li><strong>奇偶校验</strong> 方法是其中最简单的一种。如果要发送 d 比特的数据，在这些数据的最后附加一个比特，共 d+1 比特，附加的比特使得所有的比特位中的 1 的个数是偶数。这样，当接收方收到数据后，只需要检查 d+1 比特的数据中的 1 的个数是不是偶数，如果不是则必定在传输过程中发生了错误；但是如果是，也并不意味着一定没有发生错误，因为有可能在两个地方发生了比特翻转使得 1 的个数仍为偶数，当然这样的事情发生的概率是比较低的</li></ol><blockquote><p>上面这样的奇偶校验方法是一维奇偶校验，后来还出现了 二维奇偶校验 方法。将所有的数据分为 i 行 j 列，对每一行附加一个比特，对每一列也附加一个比特，这样总共就附加了 i+j+1 比特。每一行和每一列的附加比特都让行和列的数字 1 的数量是偶数。当某一个比特数据发生错误后，我们发现在第 n 行和第 m 列的数字 1 的个数不是偶数，那么发生错误的数据就是 n 行 m 列的数据，这样我们就能把该比特数据翻转到另一个值，我们就纠正了数据错误，这种能力叫做 前向纠错。二维奇偶校验同样能发现多于一个比特的数据错误，但这种情况下就不能纠正错误了</p></blockquote><ol start="2"><li><strong>英特网检验和（Internet checksum）</strong> 是另一种差错监测方法。从它的英文名称就可以看出，它是把二进制数据当做整数进行求和来检测差错的。比如，将数据按 16 比特分为多个整数，将所有整数求和，把和取反码就得到了检验和。把检验和附加在报文中。接收方收到数据和检验和后，同样按照 16 比特的分组把所有整数求和并取反码，如果得到的数全是 1 说明数据传输没有发生错误；而如果有一位是 0 就说明错误发生了</li></ol><blockquote><p>之前学习运输层时我们知道运输层的协议多是用检验和法，而链路层协议通常会用下面介绍的 CRC 方法。检验和方法相对于 CRC 来说偏弱一些，而因为运输层协议通常是由软件实现，因此运输层选择了偏弱但是计算更加快速的检验和方法。而链路层因为更加贴近底层硬件，而硬件专门对 CRC 提供支持，因此链路层选用了更强的 CRC</p></blockquote><ol start="3"><li><strong>循环冗余检测（Cyclic redundancy Check, CRC）</strong> 是链路层使用的差错检测技术。这个方法国语复杂，我也并没有看懂，这里就不详细记录了</li></ol><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><blockquote><p>多路访问问题 研究如何协调多个发送和接受节点对同一个共享广播信道的访问。当两个或多个节点在信道上同时发送数据时，他们的信号会彼此 <strong>碰撞（collide）</strong>，发生碰撞后任何节点都不能从信道上接受数据。因此多路访问协议要决定谁在什么时候有发送数据的权力。目前有很多多路访问协议，可以分为以下三种:</p></blockquote><ol><li><strong>信道划分协议</strong></li><li><strong>随机接入协议</strong></li><li><strong>轮流协议</strong></li></ol><p>对于一个速率是 R bps 的广播信道，多路访问协议最好有下面的特性:</p><ul><li>当仅有一个节点在发送数据时，节点应有 R bps 的吞吐量</li><li>当有 M 个节点在发送数据时，每个节点应有 R/M bps 的吞吐量。不一定要求每个节点在每个时间点都有 R/M bps 的吞吐量，而是在一个时间段内有这要的平均速率。这也要求每个节点都能平等的使用信道</li><li>协议不会因为单个节点的故障而崩溃</li><li>协议应是简单的，实现不昂贵</li></ul><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>信道划分协议有 3 种：</p><ol><li>时分多路复用（TDM）</li><li>频分多路复用（FDM） </li><li>码分多址（CDMA）</li></ol><ul><li><p>时分多路复用是把时间划分 时间帧（time frame），而一个时间帧划分为为多个 时隙（slot）。时隙会被分配给各个节点，每个节点有数据要发送时，只能等待直到自己的时隙到来才能发送。TDM 非常公平，但是当只有一个节点要发送数据时，这个节点的吞吐量被限制在 R/M bps，不能到达信道的全速</p></li><li><p>频分多路复用把信道划分为不同的频段，频道的速率是 R/M bps，频段被分配给各个节点，各个节点可以同时发送数据而不会碰撞。FDM 与 TDM 一样公平但是当只有一个节点时不能全速发送</p></li><li><p>码分多址技术给每个节点分配不同的编码，精心选择编码可以使得当多个节点同时发送数据而不发生干扰，接收方能正确接收发送方编码的数据比特（<strong>假设接收方知道发送方的编码</strong>），而不再乎其他发送方的干扰传输。</p></li></ul><h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>随机接入协议中，每个节点总是以最大的速率发送数据，当有碰撞发生时，节点等待一个随机的时间后再次尝试发送数据。随机接入协议中比较常见的有 <strong>ALOHA 协议</strong> 和 <strong>载波侦听多路访问协议（CSMA）</strong></p><h4 id="时隙-ALOHA"><a href="#时隙-ALOHA" class="headerlink" title="时隙 ALOHA"></a>时隙 ALOHA</h4><p>对时隙 ALOHA，我们做出下面的假设：</p><ul><li>所有帧由 L 比特组成</li><li>时间被划分为 L/R 的时隙，正好每一个时隙发送一帧</li><li>节点只在时隙的开始发送帧</li><li>节点是同步的，每个节点都知道时隙何时开始</li><li>如果在一个时隙中有两个或多个帧发生碰撞，节点会在时隙结束之前得知碰撞事件</li></ul><p>对于 ALOHA 协议中的操作如下：</p><ul><li>当节点有数据要发送时，等到下一个时隙开始立即传送数据</li><li>如果没有碰撞，数据的发送就成功了。如果有新帧到来，立即发送</li><li>如果有碰撞，那么有 p 的概率在下一个时隙中发送数据，直到数据没有碰撞的发送出去</li></ul><blockquote><p>相比较于 TDM 和 FDM，ALOHA 协议同样公正，而且在只有一个节点有数据发送时，它能以全速发送数据。当有大量的节点存在时，节点间会因为碰撞而造成一些时隙被浪费。我们定义一个成功的时隙就是无碰撞的成功发送了数据的时隙，而效率就是成功的时隙占所有时隙的份额。通过计算表明，当有大量的节点有发送大量的数据时，ALOHA 协议的效率大约是 1/e = 37%，有 26% 的时隙发生了碰撞</p></blockquote><h4 id="非时隙-ALOHA-协议"><a href="#非时隙-ALOHA-协议" class="headerlink" title="非时隙 ALOHA 协议"></a>非时隙 ALOHA 协议</h4><blockquote><p>时隙 ALOHA 协议中有一个假设：节点之间是同步的。但第一版的 ALOHA 协议是一个非同步协议，即节点可以在任意时间点开始发送数据。去掉节点间的必须同步的假设后，我们可以得到非时隙 ALOHA 协议的效率是 1/(2e) ，比时隙 ALOHA 协议还要小一些</p></blockquote><h4 id="载波侦听多路访问协议"><a href="#载波侦听多路访问协议" class="headerlink" title="载波侦听多路访问协议"></a>载波侦听多路访问协议</h4><p>在 ALOHA 协议中，节点决定是否发送数据与其他节点无关，这就导致当其他节点在发送数据时，另一个节点也开始发送数据就必定使得碰撞发生。而如果节点如果能够侦听到另一个节点正在发送数据，那么它决定在另一个节点结束发送数据后才发送自己的数据，这将避免碰撞的发生。这就是 载波侦听 原理</p><p>除此之外还有一个重要的原理叫做 碰撞检测（collision detection），即节点在发送数据时同时也在侦听网络，一些发生另一个节点发送的信号与自己发送的信号相互干扰后就立即停止发送</p><p>这两个规则被包含在 载波侦听多路访问协议（Carrier Sense Multiple Access, CSMA） 和 具有碰撞检测的 CSMA（CSMA with Collision Detection, CSMA/CD） 协议族中</p><p>如果说节点具有载波侦听功能，那么为什么还会发生碰撞呢？这是因为信号在信道中传播的速度是有限的，当一个节点 A 开始传送数据后，另一个节点 B 可能需要过一段时间才能侦听到信号，如果 B 在侦听到信号之前也开始传送数据，那么此时碰撞就发生了</p><p>在检测到碰撞后，节点会等待一个随机的时间后再次尝试发送数据。这个随机的时间量选择也是有一个算法的，叫做 二进制指数后退（binary exponential backoff）。即当节点连续发生 n 次碰撞后，它会从 {0, 1, 2, 4, … , 2^n -1 } 的常数中随机选择一个值 K 。在以太网协议中，等待的时间是 K * 传送 512 比特所需要的时间，作为随机等待的时间。n 能取到的最大值一般是 10</p><p>经过一系列复杂的计算，我们可以得到 CSMA/CD 的效率是 1 / (1 + 5 d1/d2) ，其中 d1 是信号在两个节点间传播所需要的最大时间，d2 是传递一个最大长度的以太网帧所需要的时间。当 d1 越小时，传播速率越接近于 1 ，即信号传播速度越快，碰撞越不可能发生</p><h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><p>轮流协议（taking-turns protocol）也有很多种。</p><p>第一种轮流协议是 轮询协议（polling protocol）。这个协议要求一个节点被指定为主节点，主节点轮询每个节点，告诉每个节点它能传送的帧的数量。比如主节点告诉节点 1 它能传送的帧的数量，当节点 1 传送完这些帧后，主节点告诉节点 2 能传送的帧的数量，依此类推。这个协议需要轮询每个节点，这就引入了轮询时延，导致效率有所降低。第二个缺点是当主节点出现故障，整个信道都不可用了。802.15 协议和蓝牙协议就使用了轮询协议</p><p>第二种轮流协议是 令牌传递协议（token-passing protocol）。这个协议没有主节点，而是存在一个称为 令牌（token） 的特殊帧，令牌只有一个，在每个节点之间以固定的次序传输。如果一个节点有数据需要发送，它会尝试去获取令牌，只有当它拿到令牌后才会开始发送数据。如果节点拿到了令牌却没有数据需要发送，那么它会把令牌传递给下一个节点。下一个节点会根据自己有没有数据需要发送而决定是自己保留令牌还是传给另一个节点。令牌传送协议效率很高且分散，但是也有自己的缺点。如果一个节点发生故障，没有适时交出令牌，那么整个网络将会瘫痪，必须通过某种令牌恢复策略才能从瘫痪中恢复</p><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><blockquote><ul><li>主机除了具有英特网 IP 地址外，他们还有另外一种地址，即 MAC 地址。严格来说，是主机的网络适配器具有 MAC 地址。对于有多个接口的路由器，每一个接口都对应了一个 MAC 地址</li><li>MAC 地址总长度是 6 字节，因此共有 2^48 个可能的地址，大约是 200 万亿个，数字这么大以至于目前世界上没有两个网卡具有相同的 MAC 地址</li></ul></blockquote><h3 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h3><p>因为有网络层地址（IP 地址）和链路层地址（MAC 地址）的存在，就需要在两者之间进行转换，这个转换的协议就是 <strong>地址解析协议（Address Resolution Protocol，ARP）</strong></p><p>ARP 实际上与 DNS 协议特别像，即 DNS 将域名解析成 IP 地址，而 ARP 将 IP 地址解析成 MAC 地址。不过 DNS 能解析网络上任意一个位置的主机的域名，而 ARP 只能解析同一个子网下的 IP 地址的 MAC 地址</p><p>在一个主机上会有一个叫做 ARP 表 的数据解构，里面保存着子网内的 IP 地址到 MAC 地址的映射，其中的每一个项目的过期时间通常是 20 分钟。当主机需要向一个 IP 地址发送数据时，会现在自己的 ARP 表中搜索这个地址的 MAC 地址。如果表中不存在这个映射关系，那么就需要借助 ARP 协议了。主机回想子网内广播一个 ARP 分组（ARP Packet）。这个分组包含发送方和接收方的 IP 地址和 MAC 地址，ARP 的响应分组和请求分组具有相同的结构</p><p>在请求分组中，发送方将分组发向 MAC 地址是 FF-FF-FF-FF-FF-FF 的接受主机，这个地址实际上是广播地址，因此所有的主机在收到这个分组后，都会选择接受它。接受后，主机会检测请求分组中请求解析的 IP 地址是不是自身，如果不是，主机会把这个请求分组丢弃；而如果是，那么主机会构造一个相同的响应分组，不过这个分组不会是一个广播帧，而是发向请求的主机。请求主机收到后也就知道了自己想要的结果</p><p>MAC 地址只能在子网内部使用，如果主机需要把数据发向子网以外的主机，那么该如何构造分组呢？实际上，这个分组的 IP 地址是实际接受主机的地址（即子网外的地址），而 MAC 地址是网关路由器的 MAC 地址。因此这个分组会在子网内部被传递给网关，网关收到这个分组后，读取发送的 IP 地址，重新构造一个链路层分组，把其中的 MAC 地址修改成下一个接受这个分组的路由器的 MAC 地址</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>以太网的帧结构</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jcjmr.png" alt="链路层帧结构"></p><ul><li><p>前同步码 （8 字节）：前同步码的存在是为了让接收方的适配器与发送方的适配器在时钟上进行同步，虽然以太网链路层具有一个确定的速率，但是发送适配器可能相对于这个速率有一定的偏移，因此接受适配器需要一定的时间去确定发送方的速率。前同步码的前 7 个字节都是 10101010 这样的循环，最后一个字节是 10101011，最后的 11 就告诉了接收方重要的数据要来了</p></li><li><p>目的地址（6 字节）：接受适配器的 MAC 地址。接受适配器收到了目的地址与自己的 MAC 地址相同的以太网帧、或者目的地址是广播地址的帧，就会把帧的数据部分传递给网络层，否则丢弃这个帧</p></li><li><p>源地址（6 字节）：即发送方的网络适配器地址</p></li><li><p>类型字段（2 字节）：这个字段指明了这个帧的网络层使用了什么协议，比如 0x8086 是 ARP 分组</p></li><li><p>数据字段（46 ~ 1500 字节）：数据字段承载了 IP 数据报，以太网的最大传输单元 MTU 是 1500 字节，对于超过 1500 字节的 IP 数据报，以太网必须把数据报拆开成两个以太网帧。以太网的最小传输单元是 46 字节，所以对于小于 46 字节的数据，以太网会把数据填充到 46 字节。被填充的数据传送到接收方后，接收方的适配器会把 46 字节的数据交付给网络层，网络层读取 IP 数据报首部中的数据长度字段，并去除填充数据</p></li><li><p>CRC：CRC 的目的是让适配器能够检测以太网帧在传输过程中是否发生了错误</p></li></ul><p>以太网提供无连接、不可靠的服务</p><blockquote><p><strong>在以前，以太网的链路是总线拓扑结构或者基于集线器的星型拓扑结构，因此是一条广播链路（一个接口收到比特将从其所有接口进行转发，如果同时两个接口收到比特将发生碰撞，生成该帧的结点必须重新传输）。</strong></p></blockquote><p>但是现在，多数以太网是基于<strong>交换机</strong>的星型拓扑结构，这意味着一条链路上只有首尾两个交换机，交换机不会向一个接口上发送超过一个帧，而且首尾交换机是全双工的，表示两个交换机可以能够同时向链路上发送以太网帧而不会发生碰撞，因此现在没有必要使用 MAC 协议了</p><h2 id="Web-页面请求的里程"><a href="#Web-页面请求的里程" class="headerlink" title="Web 页面请求的里程"></a>Web 页面请求的里程</h2><hr><p>Bob 拿着他的笔记本电脑到了图书馆内，连上图书馆的以太网，打开浏览器访问 <a href="http://www.google.com/" target="_blank" rel="noopener">www.google.com</a> 。在这一过程中，他的电脑究竟发出了哪些请求呢？</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP 发生在电脑连上了网线与浏览器请求 Web 页面之间。刚插上网线的时候，电脑此时还没有一个 IP 地址，因此必须先获得一个地址，这是通过 DHCP 协议完成的：</p><ol><li><p>Bob 的电脑先要构造一个 DHCP 请求报文。这是一个 UDP 报文，目的端口是 67（DHCP 服务端口），源端口是 68（DHCP 客户端口）；目的地址是 255.255.255.255（广播地址），源地址是 0.0.0.0（本机地址）。因为电脑此时还不知道 DHCP 服务端的地址，而且自己也没有地址</p></li><li><p>DHCP 请求报文的 IP 数据报被放入以太网帧中。以太网帧的目的 MAC 地址是 FF:FF:FF:FF:FF:FF，使该帧将被广播到与交换机连接的所有设备（如果顺利也包括DHCP服务器），源 MAC 地址是 Bob 电脑的 MAC 地址（假设是 00:16:D3:23:68:8A）</p></li><li><p>这个包含DHCP请求的广播以太网帧是第一个由Bob设备发送到以太网交换机的帧，以太网帧被发送到交换机的一个接口上，交换机把这个帧广播到它所有的输出接口上，包括连接到路由器的端口；</p></li><li><p>运行着 DHCP （应用层，使用UDP协议）服务的路由器在它的一个接口拥有MAC地址 00:22:6B:45:1F:1B 收到了这个以太网帧，分解出 UDP 报文后向上传递到 67 端口的进程上</p></li><li><p>我们假设 DHCP 服务能够以 CIDR 块 68.85.2.0/24 分配 IP 地址，因此它分配了地址 68.86.2.101 给 Bob 的电脑。DHCP 服务生成一个 DHCP ACK 报文，报文中包含 68.86.2.101 地址、DNS 服务器的 IP 地址（68.87.71.226）、默认网关路由器的 IP 地址（65.85.2.1）、子网块（68.85.2.0/24），这个报文被放入一个 UDP 报文，UDP报文段被放入一个IP数据报中，IP数据报再被放入一个以太网帧中。以太网帧的源 MAC 地址是路由器接收到请求的接口的地址（00:22:6B:45:1F:1B），目的 MAC 地址是 Bob 的电脑的 MAC 地址（00:16:D3:23:68:8A）</p></li><li><p>以太网帧被路由器发送到交换机上。交换机是自学习的，它知道 Bob 的 DHCP 请求报文是从自己的哪个接口收到的，因此会把这个以太网帧也发送到这个接口上</p></li><li><p>Bob 接收到了 DHCP ACK 的以太网帧，从中抽取IP数据报，在从IP数据报中抽取UDP报文段，再从UDP报文段中抽取DCHP ACK报文，取出了分配的 IP 地址、DNS 服务器地址、默认网关地址、子网块等信息。Bob 的笔记本把所有目的地址是 68.85.2.0/24 之外的报文都发送给默认网关。到了这里，Bob 的电脑就算已经连上互联网了</p></li></ol><h3 id="DNS-与-ARP"><a href="#DNS-与-ARP" class="headerlink" title="DNS 与 ARP"></a>DNS 与 ARP</h3><p>这时 Bob 的电脑已经能连上网了，当他键入 <a href="http://www.google.com/" target="_blank" rel="noopener">www.google.com</a> 时，并不知道这个域名对应的 IP 地址是什么，因此需要借助于 DNS 协议。但是在发送 DNS 请求之前，还需要解决一个问题：Bob 的电脑这时并不知道默认网关的 MAC 地址。在发送 DNS 请求之前，必须先发送 ARP 请求获得网关的 MAC 地址</p><ol><li><p>Bob 的电脑生成一个目的地址是 65.85.2.1 的 ARP 查询报文，目的 MAC 地址是 FF:FF:FF:FF:FF:FF 。这个以太网帧被发送给交换机后，交换机把这个帧发送给所有的设备，包括网关路由器</p></li><li><p>默认网关在收到 ARP 查询报文后，发现报文中的目的地址与自己的地址匹配，因此网关准备一个 ARP 回答，在其中包含了自己的 MAC 地址（00:22:6B:45:1F:1B），装入以太网帧中，目的地址是 00:16:D3:23:68:8A，交付给交换机，再由交换机交付给Bob</p></li><li><p>路由器接受到 ARP 回答报文后，交付给 Bob 的电脑，Bob 的电脑从中得知了网关的 MAC 地址</p></li><li><p>Bob 的电脑此时终于能构造 DNS 报文查询域名的 IP 地址了。它构造的 DNS 报文的目的 IP 地址是 68.87.71.226，目的 MAC 地址是 00:22:6B:45:1F:1B（网关），交换机收到这个帧后把它发送给网关路由器</p></li></ol><h3 id="开始-DNS-查询"><a href="#开始-DNS-查询" class="headerlink" title="开始 DNS 查询"></a>开始 DNS 查询</h3><ol><li>DNS 查询报文发送给了网关，网关根据 IP 数据包的目的地址，就这个报文重新封装，发送给了 DNS 服务器</li><li>DNS 服务器收到了查询报文，在自己的 DNS 数据库中找到与 <a href="http://www.google.com/" target="_blank" rel="noopener">www.google.com</a> 匹配的记录，将这条记录变成 DNS 回答报文，使用 UDP 协议发送给 Bob 的电脑</li><li>Bob 的电脑收到了 DNS 回答报文后，终于知道了 <a href="http://www.google.com/" target="_blank" rel="noopener">www.google.com</a> 的 IP 地址，可以开始发送 HTTP 请求了</li></ol><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/my3om.png" alt=""></p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/83ugo.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chapter4-网络层</title>
      <link href="/2019/09/14/ji-suan-ji-wang-luo/chapter4-wang-luo-ceng/"/>
      <url>/2019/09/14/ji-suan-ji-wang-luo/chapter4-wang-luo-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><p>虚电路服务 可靠通信应当由网络来保证<br>数据报服务 可靠通信应当由用户主机来保证<br>因特网网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p><h2 id="转发和路由选择"><a href="#转发和路由选择" class="headerlink" title="转发和路由选择"></a>转发和路由选择</h2><p>转发和路由选择这两个概念很重要，一定要区分开，他们的严格定义如下：<br><strong>转发</strong>：将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。<br><strong>路由选择</strong>：确定分组从源到目的地所采取的端到端路径的网络范围过程。</p><p>注：<br>转发发生的时间尺度很短（通常为几纳秒），因此通常用硬件来实现<br>路由选择发生的时间尺度长得多（通常为几秒），因此通常用软件来实现</p><p>本章数据平面的主要工作就是转发。</p><p>链路层交换机和路由器<br>某些分组交换机称为链路层交换机，基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层设备<br>其他分组交换机称为路由器，基于网络层数据报中的首部字段值做出转发决定</p><p>每个路由器都有一个转发表，路由器根据分组目的地前缀与该路由表中的表项进行匹配，找到对应的出口进行转发。 </p><h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p>路由器最主要的作用就是把接收到的一个包通过另一个端口转发出去，这个过程中就涉及到很多问题了，比如路由器怎么知道向哪个口转发？它怎么选择转发链路等等。</p><p>当路由器的输入端口接收到网络包时，理论上可以用三种方式来交换要转发的网络包。分别为内存交换、总线交换、网络交换。其中内存交换我个人觉得可以理解为共享内存；总线交换即所有的输入输出端口都连接到同一条总线上去；而网络交换着更高级了，因为它不止一条线路，所以只要两个包不是走同一条线路，那么路由器就能实现非阻塞式的转发。</p><p>当然，如果对一个输入端口狂输入网络包，或者输出端口来不及转发网络包，那很容易就会出现丢包的情况，因为缓存已经撑爆了，要解决这个问题要么加大缓存、要么提升交换速率。</p><p>但是再怎么样都会出现丢包的问题，所以就搞个排队机制，只要您进了队列，那么就不会被抛弃，但是进了队列就不代表一定就会把你发出去</p><h2 id="分组调度的几种规则"><a href="#分组调度的几种规则" class="headerlink" title="分组调度的几种规则"></a>分组调度的几种规则</h2><p>1、先进先出<br>如果链路当前忙于传输另一个分组，到达链路输出队列的分组要排队等待传输。如果没有足够的缓存空间来容纳到达的分组，队列的分组丢弃策略则确定该分组是否将被丢弃或者从队列中去除以便为到达的分组腾出空间<br>2、优先权排队<br>通常由源或目的TCP、UDP端口号来进行分组。如实时话音分组可能获得超过非实时流量的优先权。<br>同一个队列中的还是采用先进先出的策略。<br>3、循环和加权公平排队<br>把分组进行分类然后赋予一个权重w，然后调度器循环的在各个类之间进行分组的传输</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>1、与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP</li><li>网际控制报文协议 ICMP</li><li>网际组管理协议 IGMP</li></ul><p>2、网络互相连接起来要使用一些中间设备</p><p>3、互联网可以由许多异构网络互联组成</p><p>4、分类的 IP 地址<br>IP 地址定义：就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。</p><p> 5、IP 地址的编址方法 分类的 IP 地址，子网的划分，构成超网。<br>两级的 IP 地址 ：IP 地址 ::= { &lt;网络号&gt;, &lt;主机号&gt;}<br>分类的 IP 地址：A类，B类，C类地址都是单播地址<br>D类地址用于多播，E类地址保留<br>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。<br>Ip地址不仅可以指明一个主机，还指明了主机所连接到的网络<br>点分十进制记法：192.168.1.1<br>一些特殊的ip地址：保留地址0.0.0.0 本地软件环回测试地址127.0.0.1<br>不指派地址 128.0.0.0 192.0.0.0<br>6、ip地址与硬件地址的区别：IP地址放在IP数据报首部，硬件地址放在MAC帧首部，在网络层及网络层以上使用IP地址，在链路层及以下使用硬件地址</p><p>7、解析协议 ARP 每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，这个映射表还经常动态更新。</p><p>8、如何知道同一个局域网内其他主机的mac地址？<br>A在局域网内广播arp请求分组，其他主机接收分组，IP地址与报文中一致的主机收下分组，并在自己的arp缓存中写入主机A的IP地址到mac地址的映射，并发送arp响应报文，A收到响应报文后在自己的arp缓存中写入主机B的IP地址到mac地址的映射。</p><p>9、若主机不在同一个局域网内，arp映射表怎样建立？ 交给连接不同网络的路由器</p><p>10、 为什么不直接使用mac地址通信，要加上ip地址<br>为了完成异构网络之间的通讯，mac地址比较复杂，ip方便用户操作，提高CPU的效率，这样在网络传输中就可以由网卡来识别mac地址，不用再上传到CPU识别</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>1、需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IPG。<br>2、在专用网络内使用专用IP地址，仅在连接到英特网上的路由器时使用全球IP地址。并且一定要使用全球IP才能和英特网连接<br>3、通过NAT地址转换表可以把IP数据报上的旧目的IP地址转换为新的目的IP地址<br>4、使用端口号的NAT也叫网络地址与端口号转换NAPT</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chapter3-传输层</title>
      <link href="/2019/09/14/ji-suan-ji-wang-luo/chapter3-chuan-shu-ceng/"/>
      <url>/2019/09/14/ji-suan-ji-wang-luo/chapter3-chuan-shu-ceng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这周来到，《自算计网络自顶向下》 这本书的第三章，传输层的学习。</p></blockquote><h2 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h2><p>  在协议栈中，我们都知道运输层位于网络层之上。网络层提供了主机之间的通信，而运输层为位于主机上的不同进程之间提供了逻辑通信。</p><h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p>首先我们需要明确，一个进程有一个或者多个套接字，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。在接收主机上的运输层实际上并没有将数据报直接交给进程，而是将数据报交给了一个中间套接字。<br>现在我们就可以考虑接收主机怎样将一个运输层报文段传输到适当的套接字。为此目的，每个运输层的报文段中具有几个字段。在接收端运输层通过检查这几个字段，进而标识将数据定向到指定套接字。将运输层报文段正确交付给套接字的工作成为<strong>多路分解</strong>。<br>对应的在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息生成报文段，然后将此报文段传递到网络层，所有这些工作成为<strong>多路复用</strong>。</p><p>在主机中如果将报文段识别定向到对应的套接字是通过<strong>端口号</strong>来标识的。<br><strong>总结：</strong> 在主机上的每个套接字能分配一个对应的端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到对应的套接字。最后通过套接字进入到其所连接的进程。</p><h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><p>UDP协议是不需要建立连接的传输，也就是无需三次握手，是一种不可靠传输，而且没有提供拥塞控制。</p><p>有可能引发，所有基于UDP协议的应用程序客户端，都没有流量控制，可能会使整条链路流量带宽被耗尽，其他UDP客户端的高丢包率，也可能使TCP应用没有带宽可用，因为它的拥塞控制，会限制数据报的发送。</p><p>UDP提供了<strong>检验和</strong>来验证数据报的正确性，之所以提供这种手段，原因在于不能保证源和目的之间的所有链路都提供了差错校验； 也就是说，这些链路中也许某一条使用没有差错校验的协议。此外，即使报文经链路正确的传输，当报文段存储在某台路由器内存时，也可能引入比特差错，因此UDP 在端到端基础上在运输层提供差错校验。</p><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/kj2u4.png" alt="可靠数据传输：服务模型与服务实现"></p><p>在可靠传输协议中，为了提高发送效率一般采用流水线，即无需等待确认回复，继续发送下一个分组，下面记录下解决流水线差错恢复的两种基本方法： <strong>回退N步（Go_Back_N,GBN）</strong> 和 <strong>选择重传(Selective Repeat, SR)</strong></p><h3 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h3><blockquote><p>在回退N步协议中，允许发送方发送多个分组（当有多个分组可用时）而不需要等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p></blockquote><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/k07p7.png" alt="在GBN中发送方看到的序号"></p><p>在上图中，展示了发送方看到的GBN协议的序号范围。如果我们将基序号（base）定义为最早的未被确认的分组序号，将 下一个序号（nextseqnum） 定义为最小的未使用序号（即下一个待发分组号），则可以将序号范围划分为4段：</p><ol><li>在[0,base-1] 段内的序号对应于已经发送b并被确认的分组。</li><li>[base,nextseqnum-1]段内对应已经发送但未被确认的分组。</li><li>[nextseqnum,base+N-1] 段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话。</li><li>最后，大于或者等于base+N的序号是不能使用的，直到当前流水线中未被确认的分组已得到确认为止。</li></ol><p>GBN协议也被称为<strong>滑动窗口协议</strong></p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/csxo3.png" alt="可靠数据传输机制及其用途的总结"></p><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>TCP是一个全双工通信模型，简要概括如下图所示：<br><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/a3e21.png" alt="TCP发送缓存和接收缓存"></p><h3 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h3><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jl4qk.png" alt="TCP报文结构"></p><ol><li>序号和确认号<br>TCP报文段首部中最重要的字段是序号和确认号。因为他们是TCP可靠传输服务的关键部分。</li></ol><p>TCP 将数据看成是一个无结构的，有序的字节流。这里需要强调序号是建立在传送的字节流上的，而不是建立在传输的报文段的序列之上。</p><p><strong>一个报文段的编号</strong> 是该报文段首字节的字节流编号。 </p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/i12ey.png" alt="文件数据划分成TCP报文段"></p><p>确认号是接收主机期望从发送主机收到的下一字节的序号。</p><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP在发送数据后，假设丢包采用累计确认，后面的确认了则前面未确认的都认为已经接收到了，不在重传。</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2cwdd.png" alt="TCP三次握手-报文交换"></p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/997bg.png" alt="关闭一条TCP连接"></p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/c6k3s.png" alt="客户TCP经历的典型TCP状态序列"></p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/rjr8k.png" alt="服务端TCP经历的典型TCP状态序列"></p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>TCP使用的端到端的拥塞控制，而不是使用网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。</p><p>TCP拥塞控制算法：</p><ol><li>慢启动</li><li>拥塞避免</li><li>快速恢复</li></ol><p>总结：TCP控制是：每个RTT内cwnd线性（加性）增加1MSS，然后出现3个冗余ACK事件时 cwnd减半（乘性减）。因此，TCP拥塞控制常被称为 <strong>加性增，乘性减</strong>拥塞控制方式。</p><p><strong>TCP是非常复杂的，它涉及了连接管理（三次握手，四次挥手）、流量控制（滑动窗口）、往返时间估计（RTT加权）、以及可靠数据传送（确认、定时器、重传以及序号机制）</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chapter2-应用层</title>
      <link href="/2019/09/14/ji-suan-ji-wang-luo/chapter2-ying-yong-ceng/"/>
      <url>/2019/09/14/ji-suan-ji-wang-luo/chapter2-ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本周进入到第二章应用层的学习，不得不说自顶向下学习果然能激发兴趣，因为平时开发工作经常也就是和应用层打交道，但是对具体原理总是一知半解，随着这章的阅读，能让自己对我们开发的应用程序，是怎样利用网络实现其功能的，有了更深入的了解。</p></blockquote><p>我们日常中所用到的，开发的软件基本都是基于应用层的软件。不需要关心数据包到底是如何传输的，只需要按照应用层对接下一层的协议接口进行开发就可以了。 </p><p>应用程序体系结构，我们最常用的是客户-服务器体系结构，比如生活中最常用的浏览器就是这种模式的。有一个总是打开的服务器用来接收各个客户端的请求，返回对应的数据。  另一个就是P2P 体系结构，和客户-服务器相反，这些应用程序在间断连接的主机之间使用直接通信，这些主机也被称为对等方。</p><p>在操作系统中，程序之间的通信是通过进行来进行的，而不是程序。一个进程可以被认为是一个端系统中的一个程序，当进程运行在同一个端系统上时，它们使用进程间通信机制进行通信。进程间的通信规则有端系统山的操作系统决定。</p><p>我们现在知道了多数应用程序是通过通信进程对组成，每对中的两个进行 互相发动报文。从一个进程向另一个进行发送报文必须通过下层的计算机网络。这里进程是通过一个被称之为套接字的软件接口向网络发送报文和从网络接收报文的。</p><p><strong>进程寻址</strong> </p><p>为了向特定的目的地的主机上的进程发送分组，接收进程需要一个地址，而为了标识接收进程是需要通过：</p><ol><li>主机的地址；</li><li>定义在目标主机的进程的端口号；</li></ol><p>我们在开发应用层程序时，是不需要考虑具体是怎样将发送的数据分组发送到目的主机的，对于应用层程序来说，只需要将数据分组推送进套接字。而在套接字的另一侧， 运输层协议负责使该数据分组进入接收进程的套接字。</p><p>因特网提供的运输层的协议不止一种，我们最常见的当属 TCP、UDP 了，具体使用需要从以下几个方面进行衡量：</p><ol><li>可靠数据传输；</li><li>吞吐量；</li><li>定时</li><li>安全性；</li></ol><p>总结来说，TCP 提供了可靠地数据传输，因为其建立在三次握手的基础上，能够保证数据到达目的进程。UDP 是一种轻量级运输协议，没有拥塞控制，提供一种不可靠数据传输服务，也就是说，UDP客户端可以用任何它选定的速率向其下层注入数据，一般网络电话可以容忍范围内的数据丢失，更愿意应用运行在UDP上。</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>说到Web其应用层协议就是HTTP。<br>HTTP 请求报文：</p><pre class=" language-html"><code class="language-html">GET /api/monitoring/converged-status HTTP/1.1\r\nHost: 192.168.8.1\r\nConnection: keep-alive\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36\r\nAccept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8\r\n</code></pre><p>第一行为请求航，其后的都叫做首部行。</p><p>请求行的三个字段代表的是 方法字段、URL字段、HTTP版本字段<br>当请求为POST方式时，在首部行下方还有一个实体体，用来存放表单提交的数据。</p><p>HTTP响应报文：</p><pre><code>HTTP/1.1 200 OK\r\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\r\nContent-Type: text/html\r\nConnection: Keep-Alive\r\nContent-Length: 1073\r\nFile Data: 1073 bytes</code></pre><p>响应报文，也有三个部分，状态行、首部行、然后是实体体。实体体是报文的主要部分，即它包含了所请求对象的本身。</p><h3 id="FTP文件传输协议"><a href="#FTP文件传输协议" class="headerlink" title="FTP文件传输协议"></a>FTP文件传输协议</h3><p>应用层协议FTP，作为一个文件传输协议，其和HTTP有相似的地方，底层都采用TCP传输协议，然而这两个应用也有也有一些重要的区别，其中最显著的就是 <strong>FTP</strong> 使用了两个并行的 <strong>TCP</strong> 连接来传输文件，一个是控制连接，一个是数据连接。 <strong>控制链接</strong> 用来在两主机之间传入控制信息，如用户表示、口令、改变远程目录的命令以及存放和获取文件的命令。数据连接用来实际发送一个文件。</p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP 是因特网电子邮件应用的核心，这个协议是用来从发送方的邮件服务器发送报文到接收方的邮件服务器的。</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/poj7j.png" alt=""></p><p>如上图所示，SMTP 的作用就是将邮件报文从发送邮件服务器送到接收邮件服务器。 下面大概解释下具体流程。<br>首先，客户SMTP（运行在发送邮件服务器上）在25 端口建立一个到服务器SMTP（运行在接收邮件服务器上）的TCP连接。 如果服务器没有开机，客户会在稍后进行重试，一旦连接建立，服务器和客户执行某些应用层的握手后，就向人们在互相交流前先进行自我介绍一样。在SMTP握手阶段，SMTP 客户指示发送方邮件地址（产生报文的那个人）和接收方邮件地址，一旦该SMTP客户和服务器彼此介绍之后 ，客户发送该报文。</p><p>这里在记录一个比较明显的问题，那就是在Bob的邮件服务器接收到邮件后，他的本地PC上的代理是如何获得位于他的某ISP 邮件服务器上的邮件呢？ 这里不能再使用SMTP了，因为这里需要的是一个拉协议， 而SMTP 是一个推协议，目前流行的一些邮件访问协议可以解决这个问题，包括第三版的邮局协议（POP3） 、因特网邮件访问协议（Internet Access Protocol，IMAP） 以及HTTP。</p><p>总结: SMTP 用来将邮件从发送方的邮件服务器传输到接收方的邮件服务器；SMTP 也用来将邮件从发送方的用户代理传送到发送方的邮件服务器。如POP3这样的邮件访问协议可以用来将邮件从接收方的邮件服务器传送到接收方的用户代理。</p><h3 id="DNS-（Domain-Name-System）"><a href="#DNS-（Domain-Name-System）" class="headerlink" title="DNS （Domain Name System）"></a>DNS （Domain Name System）</h3><blockquote><p>DNS 是： 1. 一个由分层的 <strong>DNS服务器</strong>（DNS server） 实现的分布式数据库；2. 一个使得主机能够查询分布式数据库的应用层协议。 DNS服务器通常是运行BIND (Berkeley Internet Name Domain) 软件的UNIX机器。 DNS 协议运行在 UDP之上，使用53号端口。与 HTTP、FTP 和 SMTP 协议一样，DNS 协议是应用层协议。</p></blockquote><p>DNS服务器不可能是单一部署的，它是一个巨大的具有代表性的分布式数据库；</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v7fiq.png" alt=""></p><p>DNS 是由很多DNS服务器组成，映射关系分布在全世界范围内的所有DNS服务器上。 </p><p>DNS服务器分为三种： 根DNS服务器、顶级域（TOP-Level Domain，TLD） DNS服务器和 权威DNS服务器。</p><p>接下来记录一下，这三种DNS服务器之间的交互方式， 假设我现在要访问 <code>www.baidu.com</code> , 首先我本机的DNS客户端与根服务器之一联系，它将返回顶级域名 com 的TLD服务器 IP地址。然后 我在与这些TLD服务器之一联系，它将返回 baidu.com 的权威服务器的 IP地址。最后我将与 baidu.com 权威服务器之一联系，它将为 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 返回其 IP 地址。</p><p>上面说的三类DNS服务器都是处在 DNS服务器的层次结构中， 在这里我们学习到还有一类非常重要的DNS服务器，称为 <strong>本地DNS服务器</strong>。 一个 本地DNS服务器，严格来说不属于DNS服务器的层次结构，但它是非常重要的。 每个 <strong>ISP(Internet Service Provider)</strong>  都有一台本地DNS 服务器。 通过访问Windows 或者UNIX 的网络状态窗口，能够很容易的确定你本地DNS服务器的IP地址。 一般 本地DNS服务器“临近” 本主机。 基本上 ISP 的本地DNS服务器与主机相隔不超过几个路由器。</p><p><strong>下面这幅图用来理解本地DNS服务器在交互中起的作用：</strong></p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/000vv.png" alt=""></p><p>接下来，要说一个DNS系统中非常重要的一个特色，DNS 是有缓存的。为了减少时延并且有效减少因特网上到处传输的DNS报文数量， DNS 会将每一个DNS 回答缓存在本地存储中。 例如本地DNS服务器在接收到一个回答时，它能够将回答中的任何信息都缓存起来，在下一个相同主机名查询时可以直接返回。<strong>由于主机和主机名以及IP地址之间的映射不是永久的，因此会有一个过期时间，一般缓存2天。</strong></p><blockquote><p>本地 DNS服务器 也能缓存 TLD服务器的IP 地址，因而允许本地DNS绕过查询链路中的根DNS服务器。</p></blockquote><p>学习了上面几种应用层协议，接下来我们了解下P2P协议。</p><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>说到P2P我们常见的就是文件分发了，它和客户端-服务器模式不同，采用了一种对等方的概念。</p><p>举例来说，平时我们用的种子下载，传统下载我们是从本地客户端和资源服务器建立连接，从服务器下载，下载速度受限于服务器的上载速率以及本地客户端网络的下载速率。 而P2P下载则是所有下载方都是可以一边下载，一边将自己已经下载的资源利用上载带宽上传供其他下载者下载，从而提高效率。</p><p>常见的应用有如：BitTorrent等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chapter1-计算机网络和因特网</title>
      <link href="/2019/09/14/ji-suan-ji-wang-luo/chapter1-ji-suan-ji-wang-luo-he-yin-te-wang/"/>
      <url>/2019/09/14/ji-suan-ji-wang-luo/chapter1-ji-suan-ji-wang-luo-he-yin-te-wang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近参加了码农翻身的读书活动，目标是读完《计算机网络 自顶向下方法》 这本书，这篇文章将记录第一周所看到的本地第一章的相关内容。</p></blockquote><h2 id="学习计算机网络首先学习下什么是因特网？"><a href="#学习计算机网络首先学习下什么是因特网？" class="headerlink" title="学习计算机网络首先学习下什么是因特网？"></a>学习计算机网络首先学习下什么是因特网？</h2><p>描述这个问题需要从两个方面论述。</p><ol><li>具体构成描述<blockquote><p>因特网是一个世界范围的计算机网络，即它一个互联了遍及全世界的数以万计的计算设备的网络。所有与因特网相连的设备都称为<strong>主机</strong>或者<strong>端系统</strong>。</p></blockquote></li></ol><p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起。 通信链路是由不同的物理媒体组成。这些物理媒体包括同轴电缆、铜线、光纤和无线电频谱。不同的链路能够以不同的速率传输数据，链路的传输速率是以 比特/每秒 度量，（bit/s,或 bps）。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为没段加上首部字节。由此形成的信息包用计算机网络的术语称之为<strong>分组</strong>。 这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p><p>分组交换机从它的一条入通信链路接收到到达的分组，并从它的一条出通信链路转发该分组。目前常见的分组交换机类型是 <strong>路由器</strong> 和 <strong>链路层交换机</strong>。 这两种类型的交换机朝着最终目的地转发分组。链路层交换机通常用于接入网中，而路由器常用于网络核心中。 从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径。</p><p>端系统通过 <strong>因特网服务提供商</strong>（Internet Servicve Provider，ISP）接入因特网，包括如本地电缆或者电话公司那样的住宅区ISP 、公司ISP、大学 ISP，以及那些在机场等公共场所提供的WIFI 接入的ISP。 每个ISP 其实是一个由多个分组交换机和多段通信链路组成的网络。 各ISP 为端系统提供了各种不同类型的网络接入，包括线缆调制解调器或DSL 那样的住宅宽带接入、高速局域网接入、无线接入和 56kbps拨号调制解调器计入。ISP 也为内容提供者提供因特网接入服务，将Web 站点直接接入因特网。因特网就是将端系统彼此互联，因此为端系统提供接入的ISP 也必须互联。低层的ISP通过国家的、国际的高层ISP（如AT&amp;T、Sprint，联通、移动）互联起来。高层ISP 是由通过高速光纤链路互联的高速路由器组成的。无论是高层还是底层ISP网络，它们每个都是独立管理，运行着IP 协议。</p><p>端系统、分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接收和发送。TCP 和 IP 是因特网中两个最为重要的协议。 IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为 <strong>TCP/IP</strong>。</p><p>为了使各个协议以及作用取得一致，方便人们能够创造协同工作的系统和产品，因此需要制定标准。 <strong>因特网标准</strong> 由 <strong>因特网工程任务组</strong> （Internet Engineering Task Force， IETF）研发。IETF 的 标准文档被称为 <strong>请求评论（Request For Comment， RFC）</strong>。</p><ol start="2"><li>服务描述</li></ol><p>生活中我们都是用很多 app 这些被称为分布式应用程序。 大家思考下，运行在一个端系统上的应用程序怎样才能指令因特网向运行在另一个端系统上的软件发送数据呢？</p><p>与因特网相连的短息用提供了一个 <strong>应用程序编程接口</strong>（Application Ptogramming Interface， API），该API 规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。因特网 API 是一套发送软件必须遵循的规则集合，因为因特网能够将数据交付给目的地。</p><p>上面我们已经给出了因特网的两种描述方法，但是整个因特网，包括数据传输经过各层的协议，后面也会继续学习，分享出来。</p><blockquote><p>在因特网中，凡是涉及两个或多个远程通信实体的所有活动都受协议的制约。 例如，在两台物理上连接的计算机中，硬件实现的协议控制了在两块网络接口卡间的 “线上” 的比特流。</p></blockquote><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>顾名思义，网络边缘就是指位于各处的应用程序和端系统。 这里我觉得比较有意思的概念就是端系统接入网以及物理媒体。</p><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网： 指将端系统连接到其边缘路由器的物理链路。<br>边缘路由器： 是指端系统到任何其他远程端系统的路径上的第一台路由器。</p><h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><p>物理媒体划分为两类： <strong>引导型媒体</strong> 和 <strong>非引导型媒体</strong>。对于引导型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。对于非引导型媒体，电波在空气或外层空间中中传播，例如在无线局域网或数字卫星频道中。</p><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>这一节主要学习了 分组交换、电路交换、网络的网络。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>  在各种网络应用中，端系统彼此交换报文。 报文能够包含协议设计者需要的任何东西。为了源系统向目的系统发送一个报文，源将长报文划分为较小的数据块，称之为分组。在源和目的之间，每个分组都通过通信链路和分组交换机（交换机主要有两类：路由器和链路层交换机）传送。 </p><h3 id="在这里我们必须要知道的还有排队时延和分组丢失。"><a href="#在这里我们必须要知道的还有排队时延和分组丢失。" class="headerlink" title="在这里我们必须要知道的还有排队时延和分组丢失。"></a>在这里我们必须要知道的还有排队时延和分组丢失。</h3><p>每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存（也称为输出队列），它用于存储路由器准备发往那条链路的分组。该输出缓存在分组交换机中起着重要的作用。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在该输出缓存中等待。这个就叫做输出缓存的排队时延。 因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下，将出现 <strong>分组丢失（丢包）</strong>，到达的分组或已经排队的分组之一将被丢弃。</p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>首先总结的说电路交换一般用于数据链路层。 </p><p>在端系统通信会话期间，预留了端系统间通信沿路径所需要的资源（缓存，链路传输速率）。 在分组交换网络中，这些资源则不是预留的； 传统的电话网络是电路交换网络的例子。</p><h2 id="分组交换网中的时延"><a href="#分组交换网中的时延" class="headerlink" title="分组交换网中的时延"></a>分组交换网中的时延</h2><p>这部分内容应该是对于平时开发工作中非常有用的一部分，一定要掌握其相关原理。</p><p>分组从一台主机出发，通过一系列路由器传输，在另一台主机点（目的地）中结束它的历程。当分组从一个节点（主机或路由器）沿着这条路径到后续节点（主机或路由器），该分组在沿途的每个结点经受了几种不同类型的时延。这些时延最为重要的是 <strong>结点处理时延</strong>、<strong>排队时延</strong>、<strong>传输时延和传播时延</strong>，这些时延总体累计加起来是结点总时延。</p><h3 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h3><p>检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。处理时延也能包括其他因素，如检查比特级别的差错所需要的时间，该差错出现在从上游结点向路由器传输这些分组比特的过程中。高速路由器的处理时延通常是微妙或更低的数量级。在这种结点处理之后，路由器将该分组引向通往下一个路由器链路之前的队列。</p><p>​    </p><h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h3><p>在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。如果该队列是空的，并且当前没有其他分组正在传输，则该分组的排队时延为0。 另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很长。</p><p>​    </p><h3 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h3><p>假定分组以先到先服务的方式传输，这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输后，才能传输刚到达的分组。用 L 比特表示该分组的长度，用R bps （即 b/s） 表示从路由器A 到路由器B 的链路传输速率。 例如，对于一条10 Mbps 的以太网链路，速率 R = 10Mbps；  传输时延是L/R。 这是将所有分组的比特推向链路所需要的时间。实际的传输时延通常在毫秒到微妙量级。</p><h3 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h3><p>一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间是传播时延。该比特以该链路的传播速率传播。 该传播速率取决于该链路的物理媒体（即光纤、双绞铜线等），其速率范围是 2 * 10（8） ~ 3 * 10（8） m/s，这等于或略小于光速。该传播时延等于两台路由器之间的距离除以传播速率。即传播时延是 d/s, 其中 d 是路由器A 和路由器B之间的距离，s是该链路的传播速率。一旦该分组的最后一个比特传播到B结点，该比特及前面的所有比特被存储于路由器B。整个过程随着路由器B执行转发而持续下去。在广域网中，传播时延为毫秒量级。</p><p>​    </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 因特网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper深度学习2-Zab协议详解</title>
      <link href="/2019/09/08/zookeeper/zookeeper-shen-du-xue-xi-2-zab-xie-yi-xiang-jie/"/>
      <url>/2019/09/08/zookeeper/zookeeper-shen-du-xue-xi-2-zab-xie-yi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天讲解的主题是Zookeeper实现的基础协议–<strong>Zab协议（Zookeeper Atomic Broadcast）</strong>，也称为zk原子广播协议。</p></blockquote><p>首先大家可能会有疑问，<strong>Zab和我们上一篇讲解的Paxos之间有什么区别和联系？</strong>别着急，带着这个问题接着往下看吧，后面我会揭晓这个问题的答案的。</p><h2 id="一、Zookeeper简介"><a href="#一、Zookeeper简介" class="headerlink" title="一、Zookeeper简介"></a>一、Zookeeper简介</h2><p>Zookeeper是一个分布式数据一致性的解决方案，分布式应用可以基于它实现诸如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master选举，分布式锁和分布式队列等功能。<strong>Zookeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力的分布式协调系统</strong>。</p><p>考虑到Zookeeper主要操作数据的状态，为了保证状态的一致性，Zookeeper提出了两个安全属性:</p><ol><li>全序（Total order）：如果消息a在消息b之前发送，则所有Server应该看到相同的结果；</li><li>因果顺序（Causal order）：如果消息a在消息b之前发生（a导致了b），并被一起发送，则a始终在b之前被执行；</li></ol><p>为了保证上述两个安全属性，Zookeeper使用了<strong>TCP协议和Leader</strong>：</p><ol><li>通过使用TCP协议保证了消息的全序特性（先发先到）；</li><li>通过Leader解决了因果顺序问题：先到Leader的先执行，但是这样的话Leader有可能出现出现网络中断、崩溃退出与重启等异常情况，这就有必要引入Leader选举算法；</li></ol><p>而ZAB(Zookeeper Atomic Broadcast即Zookeeper原子消息广播协议)正是作为其数据一致性的核心算法，下面介绍一下ZAB协议。</p><h2 id="二、什么是Zab协议"><a href="#二、什么是Zab协议" class="headerlink" title="二、什么是Zab协议"></a>二、什么是Zab协议</h2><p>ZAB ，Zookeeper Atomic Broadcast，zk 原子消息广播协议，是专为 ZooKeeper 设计的一 种支持崩溃恢复的原子广播协议。在 Zookeeper 中，基于该协议，ZooKeeper 实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。</p><p>Zookeeper 使用一个单一主进程来接收并处理客户端的所有事务请求，即写请求。当服 务器数据的状态发生变更后，集群采用 ZAB 原子广播协议，以事务提案 Proposal 的形式广 播到所有的副本进程上。ZAB 协议能够保证一个全局的变更序列，即可以为每一个事务分配 一个全局的递增编号 xid。</p><p>当 Zookeeper 客户端连接到 Zookeeper 集群的一个节点后，若客户端提交的是读请求， 那么当前节点就直接根据自己保存的数据对其进行响应；如果是写请求且当前节点不是 Leader，那么节点就会将该写请求转发给 Leader，Leader 会以提案的方式广播该写操作，只 要有超过半数节点同意该写操作，则该写操作请求就会被提交。然后 Leader 会再次广播给 所有订阅者，即 Learner，通知它们同步数据。</p><p><img src="http://media.coderluo.top/1.png" alt=""></p><h2 id="三、Zab协议原理"><a href="#三、Zab协议原理" class="headerlink" title="三、Zab协议原理"></a>三、Zab协议原理</h2><p>Zab协议要求每个 Leader 都要经历三个阶段：<strong>发现，同步，广播</strong>。</p><ol><li><strong>发现</strong>：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表。将来客户端可以和这些 Follower节点进行通信。</li><li><strong>同步</strong>：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。这样也是提现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中</li><li><strong>广播</strong>：Leader 可以接受客户端新的事务Proposal请求，将新的Proposal请求广播给所有的 Follower。</li></ol><h2 id="四、Zab协议核心"><a href="#四、Zab协议核心" class="headerlink" title="四、Zab协议核心"></a>四、Zab协议核心</h2><p>Zab协议的核心：<strong>定义了事务请求的处理方式</strong></p><ol><li>所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做 <strong>Leader服务器</strong>。其他剩余的服务器则是 <strong>Follower服务器</strong>。</li><li>Leader服务器 负责将一个客户端事务请求，转换成一个 <strong>事务Proposal</strong>，并将该 Proposal 分发给集群中所有的 Follower 服务器，也就是向所有 Follower 节点发送数据广播请求（或数据复制）</li><li>分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），<strong>在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈</strong>后（也就是收到半数以上的Follower的Ack请求），那么 Leader 就会再次向所有的 Follower服务器发送 Commit 消息，要求其将上一个 事务proposal 进行提交。</li></ol><p><img src="http://media.coderluo.top/2.png" alt=""></p><h2 id="五、Zab协议内容"><a href="#五、Zab协议内容" class="headerlink" title="五、Zab协议内容"></a>五、Zab协议内容</h2><p>Zab 协议包括两种基本的模式：<strong>崩溃恢复</strong> 和 <strong>消息广播</strong></p><h3 id="1-协议过程"><a href="#1-协议过程" class="headerlink" title="1.协议过程"></a>1.协议过程</h3><p>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 <strong>进入崩溃恢复模式</strong>，选举产生新的Leader。</p><p>当选举产生了新的 Leader，同时集群中有过半的机器与该 Leader 服务器完成了状态同步（即数据同步）之后，Zab协议就会退出崩溃恢复模式，<strong>进入消息广播模式</strong>。</p><p>这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。</p><h3 id="2-协议状态切换"><a href="#2-协议状态切换" class="headerlink" title="2.协议状态切换"></a>2.协议状态切换</h3><p>当Leader出现崩溃退出或者机器重启，亦或是集群中不存在超过半数的服务器与Leader保存正常通信，Zab就会再一次进入崩溃恢复，发起新一轮Leader选举并实现数据同步。同步完成后又会进入消息广播模式，接收事务请求。</p><h3 id="3-保证消息有序"><a href="#3-保证消息有序" class="headerlink" title="3.保证消息有序"></a>3.保证消息有序</h3><p>在整个消息广播中，Leader会将每一个事务请求转换成对应的 proposal 来进行广播，并且在广播 事务Proposal 之前，Leader服务器会首先为这个事务Proposal分配一个全局单递增的唯一ID，称之为事务ID（即zxid），由于Zab协议需要保证每一个消息的严格的顺序关系，因此必须将每一个proposal按照其zxid的先后顺序进行排序和处理。</p><h2 id="六、崩溃恢复"><a href="#六、崩溃恢复" class="headerlink" title="六、崩溃恢复"></a>六、崩溃恢复</h2><p><strong>一旦 Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。</strong></p><p>前面我们说过，崩溃恢复具有两个阶段：<strong>Leader 选举与初始化同步</strong>。当完成 Leader 选 举后，此时的 Leader 还是一个准 Leader，其要经过初始化同步后才能变为真正的 Leader。</p><h3 id="初始化同步"><a href="#初始化同步" class="headerlink" title="初始化同步"></a>初始化同步</h3><p><img src="http://media.coderluo.top/3.png" alt=""></p><p>具体过程如下：</p><ol><li>为了保证 Leader 向 Learner 发送提案的有序，Leader 会为每一个 Learner 服务器准备一 个队列；</li><li>Leader 将那些没有被各个 Learner 同步的事务封装为 Proposal；</li><li>Leader 将这些 Proposal 逐条发给各个 Learner，并在每一个 Proposal 后都紧跟一个 COMMIT 消息，表示该事务已经被提交，Learner 可以直接接收并执行 ；</li><li>Learner 接收来自于 Leader 的 Proposal，并将其更新到本地；</li><li>当 Learner 更新成功后，会向准 Leader 发送 ACK 信息；</li><li>Leader 服务器在收到来自 Learner 的 ACK 后就会将该 Learner 加入到真正可用的 Follower 列表或 Observer 列表。没有反馈 ACK，或反馈了但 Leader 没有收到的 Learner，Leader 不会将其加入到相应列表。</li></ol><h2 id="七、恢复模式的两个原则"><a href="#七、恢复模式的两个原则" class="headerlink" title="七、恢复模式的两个原则"></a>七、恢复模式的两个原则</h2><p>当集群正在启动过程中，或 Leader 与超过半数的主机断连后，集群就进入了恢复模式。 对于要恢复的数据状态需要遵循两个原则。</p><h3 id="1-已被处理过的消息不能丢"><a href="#1-已被处理过的消息不能丢" class="headerlink" title="1. 已被处理过的消息不能丢"></a>1. 已被处理过的消息不能丢</h3><p>当 Leader 收到超过半数 Follower 的 ACKs 后，就向各个 Follower 广播 COMMIT 消息， 批准各个 Server 执行该写操作事务。当各个 Server 在接收到 Leader 的 COMMIT 消息后就会在本地执行该写操作，然后会向客户端响应写操作成功。</p><p>但是如果在非全部 Follower 收到 COMMIT 消息之前 Leader 就挂了，这将导致一种后 果：<strong>部分 Server 已经执行了该事务，而部分 Server 尚未收到 COMMIT 消息</strong>，所以其并没有 执行该事务。当新的 Leader 被选举出，集群经过恢复模式后需要保证所有 Server 上都执行 了那些已经被部分 Server 执行过的事务。</p><h3 id="2-被丢弃的消息不能再现"><a href="#2-被丢弃的消息不能再现" class="headerlink" title="2. 被丢弃的消息不能再现"></a>2. 被丢弃的消息不能再现</h3><p>当在 Leader 新事务已经通过，其已经将该事务更新到了本地，但所有 Follower 还都没 有收到 COMMIT 之前，Leader 宕机了（比前面叙述的宕机更早），此时，所有 Follower 根本 就不知道该 Proposal 的存在。当新的 Leader 选举出来，整个集群进入正常服务状态后，之 前挂了的 Leader 主机重新启动并注册成为了 Follower。若那个别人根本不知道的 Proposal 还保留在那个主机，那么其数据就会比其它主机多出了内容，导致整个系统状态的不一致。 所以，该 Proposa 应该被丢弃。类似这样应该被丢弃的事务，是不能再次出现在集群中的， 应该被清除。</p><h2 id="八、消息广播"><a href="#八、消息广播" class="headerlink" title="八、消息广播"></a>八、消息广播</h2><p>当集群中的 Learner 完成了初始化状态同步，那么整个 zk 集群就进入到了正常工作模式 了。</p><p><img src="http://media.coderluo.top/4.png" alt=""></p><p>如果集群中的 Learner 节点收到客户端的事务请求，那么这些 Learner 会将请求转发给 Leader 服务器。然后再执行如下的具体过程：</p><ol><li>Leader 接收到事务请求后，为事务赋予一个全局唯一的 64 位自增 id，即 zxid，通过 zxid 的大小比较即可实现事务的有序性管理，然后将事务封装为一个 Proposal。</li><li>Leader 根据 Follower 列表获取到所有 Follower，然后再将 Proposal 通过这些 Follower 的 队列将提案发送给各个 Follower。</li><li>当 Follower 接收到提案后，会先将提案的 zxid 与本地记录的事务日志中的最大的 zxid 进行比较。若当前提案的 zxid 大于最大 zxid，则将当前提案记录到本地事务日志中，并 向 Leader 返回一个 ACK。（提问学员）</li><li>当 Leader 接收到过半的 ACKs 后，Leader 就会向所有 Follower 的队列发送 COMMIT 消息，向所有 Observer 的队列发送 Proposal。</li><li>当 Follower 收到 COMMIT 消息后，就会将日志中的事务正式更新到本地。当 Observer 收到 Proposal 后，会直接将事务更新到本地。</li><li>无论是 Follower 还是 Observer，在同步完成后都需要向 Leader 发送成功 ACK。</li></ol><h2 id="九、实现原理"><a href="#九、实现原理" class="headerlink" title="九、实现原理"></a>九、实现原理</h2><h3 id="1-三类角色"><a href="#1-三类角色" class="headerlink" title="1.三类角色"></a>1.三类角色</h3><p>为了避免 Zookeeper 的单点问题，zk 也是以集群的形式出现的。zk 集群中的角色主要有 以下三类：</p><ul><li>Leader：接收和处理客户端的读请求；zk 集群中事务请求的唯一处理者，并负责发起决 议和投票，然后将通过的事务请求在本地进行处理后，将处理结果同步给集群中的其它主机。</li><li>Follower：接收和处理客户端的读请求; 将事务请求转给 Leader；同步 Leader 中的数据； 当 Leader 挂了，参与 Leader 的选举（具有选举权与被选举权）；</li><li>Observer：就是没有选举权与被选举权，且没有投票权的 Follower（临时工）。若 zk 集 群中的读压力很大，则需要增加 Observer，最好不要增加 Follower。因为增加 Follower 将会增大投票与统计选票的压力，降低写操作效率，及 Leader 选举的效率。</li></ul><p>这三类角色在不同的情况下又有一些不同的名称（这个为了下一篇阅读源码做准备，可以先了解即可）：</p><ul><li>Learner = Follower + Observer</li><li>QuorumServer = Follower + Leader</li></ul><h3 id="2-三个数据"><a href="#2-三个数据" class="headerlink" title="2.三个数据"></a>2.三个数据</h3><p>在 ZAB 中有三个很重要的数据：</p><ul><li>zxid：是一个 64 位长度的 Long 类型。其中高 32 位表示 epoch，低 32 表示 xid。</li><li>epoch：每个 Leader 都会具有一个不同的 epoch，用于区分不同的时期（可以理解为朝代的年号）</li><li>xid：事务 id，是一个流水号，（每次朝代更替，即leader更换），从0开始递增。</li></ul><p>每当选举产生一个新的 Leader ，就会从这个 Leader 服务器上取出本地事务日志中最大编号 Proposal 的 zxid，并从 zxid 中解析得到对应的 epoch 编号，然后再对其加1，之后该编号就作为新的 epoch 值，并将低32位数字归零，由0开始重新生成zxid。</p><h3 id="3-三种状态"><a href="#3-三种状态" class="headerlink" title="3.三种状态"></a>3.三种状态</h3><p>zk 集群中的每一台主机，在不同的阶段会处于不同的状态。每一台主机具有四种状态。</p><ul><li><p>LOOKING：选举状态</p></li><li><p>FOLLOWING：Follower 的正常工作状态，从 Leader 同步数据的状态</p></li><li><p>LEADING：Leader 的正常工作状态，Leader 广播数据更新的状态</p></li></ul><p>OBSERVING：Observer 的正常工作状态，从 Leader 同步数据的状态</p><blockquote><p>代码实现中，多了一种状态：Observing 状态这是 Zookeeper 引入 Observer 之后加入的，Observer 不参与选举，是只读节点，实际上跟 Zab 协议没有关系。这里为了阅读源码加上此概念。</p></blockquote><h3 id="4-Zab-的四个阶段"><a href="#4-Zab-的四个阶段" class="headerlink" title="4.Zab 的四个阶段"></a>4.Zab 的四个阶段</h3><ul><li><strong>myid</strong>:这是 zk 集群中服务器的唯一标识，称为 myid。例如，有三个 zk 服务器，那么编号分别 是 1,2,3。</li><li><strong>逻辑时钟</strong>:逻辑时钟，Logicalclock，是一个整型数，该概念在选举时称为 logicalclock，而在选举结 束后称为 epoch。即 epoch 与 logicalclock 是同一个值，在不同情况下的不同名称。</li></ul><h4 id="1-选举阶段（Leader-Election）"><a href="#1-选举阶段（Leader-Election）" class="headerlink" title="1).选举阶段（Leader Election）"></a>1).选举阶段（Leader Election）</h4><p>节点在一开始都处于选举节点，只要有一个节点得到超过半数节点的票数，它就可以当选准 Leader，只有到达第三个阶段（也就是同步阶段），这个准 Leader 才会成为真正的 Leader。</p><p><strong>Zookeeper 规定所有有效的投票都必须在同一个 轮次 中，每个服务器在开始新一轮投票时，都会对自己维护的 logicalClock 进行自增操作</strong>。</p><p>每个服务器在广播自己的选票前，会将自己的投票箱（recvset）清空。该投票箱记录了所受到的选票。</p><p>例如：Server_2 投票给 Server_3，Server_3 投票给 Server_1，则Server_1的投票箱为(2,3)、(3,1)、(1,1)。（每个服务器都会默认给自己投票）</p><p>前一个数字表示投票者，后一个数字表示被选举者。票箱中只会记录每一个投票者的最后一次投票记录，如果投票者更新自己的选票，则其他服务器收到该新选票后会在自己的票箱中更新该服务器的选票。<strong>思考下：这里在实现中应该怎么实现呢？</strong>等我们分析源码时就可以看到，非常的巧妙。</p><p><img src="http://media.coderluo.top/5.png" alt=""></p><p><strong>这一阶段的目的就是为了选出一个准 Leader ，然后进入下一个阶段。</strong></p><h4 id="2-发现阶段（Descovery）"><a href="#2-发现阶段（Descovery）" class="headerlink" title="2). 发现阶段（Descovery）"></a>2). 发现阶段（Descovery）</h4><p>在这个阶段，Followers 和上一轮选举出的准 Leader 进行通信，同步 Followers 最近接收的事务 Proposal 。</p><p><strong>这个阶段的主要目的是发现当前大多数节点接收的最新 Proposal，并且准 Leader 生成新的 epoch ，让 Followers 接收，更新它们的 acceptedEpoch</strong>。</p><h4 id="3-同步阶段（Synchronization"><a href="#3-同步阶段（Synchronization" class="headerlink" title="3). 同步阶段（Synchronization)"></a>3). 同步阶段（Synchronization)</h4><p><strong>同步阶段主要是利用 Leader 前一阶段获得的最新 Proposal 历史，同步集群中所有的副本</strong>。</p><p>只有当 quorum（超过半数的节点） 都同步完成，准 Leader 才会成为真正的 Leader。Follower 只会接收 zxid 比自己 lastZxid 大的 Proposal。</p><h4 id="4-广播阶段（Broadcast）"><a href="#4-广播阶段（Broadcast）" class="headerlink" title="4). 广播阶段（Broadcast）"></a>4). 广播阶段（Broadcast）</h4><p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 Leader 可以进行消息广播。同时，如果有新的节点加入，还需要对新节点进行同步。<br> 需要注意的是，Zab 提交事务并不像 2PC 一样需要全部 Follower 都 Ack，只需要得到 quorum（超过半数的节点）的Ack 就可以。</p><h2 id="十、Zab与Paxos"><a href="#十、Zab与Paxos" class="headerlink" title="十、Zab与Paxos"></a>十、Zab与Paxos</h2><p>上面已经针对Zab协议涉及流程作了详细的描述，那么它和Paxos是什么关系呢？</p><p>Zab的作者认为Zab与paxos并不相同，之所以没有采用Paxos是因为Paxos保证不了全序顺序：</p><blockquote><p>Because multiple leaders can propose a value for a given instance two problems arise.<br>First, proposals can conflict. Paxos uses ballots to detect and resolve conflicting proposals.<br>Second, it is not enough to know that a given instance number has been committed, processes must also be able to fi gure out which value has been committed.</p></blockquote><p>Paxos算法的确是不关心请求之间的逻辑顺序，而只考虑数据之间的全序，但很少有人直接使用paxos算法，都会经过一定的简化、优化。</p><p>Google的粗粒度锁服务Chubby的设计开发者Burrows曾经说过：“<strong>所有一致性协议本质上要么是Paxos要么是其变体</strong>”。这句话还是有一定道理的，ZAB本质上就是Paxos的一种简化形式。</p><p><strong>总结：</strong>本文主要讲解了Zab上述一系列巧妙的设计，比如：为了加快收敛速度避免活锁引发的竞争引入了Leader角色，在正常情况下最多只有一个参与者扮演Leader角色，其他参与者扮演Acceptor；在这种优化算法中，只有Leader可以提出议案，从而避免了竞争使得算法能够快速地收敛而趋于一致；而为了保证Leader的健壮性，又引入了Leader选举，再考虑到同步的阶段，提出了消息广播和崩溃初始化同步以及恢复模式的两个原则。</p><p>下篇文章我们就会进入Zookeeper源码分析篇，直击源码，一起掌握核心代码逻辑。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
            <tag> Zab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper深度学习3-源码分析-Leader选举</title>
      <link href="/2019/09/08/zookeeper/zookeeper-shen-du-xue-xi-3-yuan-ma-fen-xi-leader-xuan-ju/"/>
      <url>/2019/09/08/zookeeper/zookeeper-shen-du-xue-xi-3-yuan-ma-fen-xi-leader-xuan-ju/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前两篇文章已经对Zookeeper是什么,能做什么,以及Paxos算法和底层使用的Zab协议做了详细的描述（如果你还不了解Paxos算法和Zab协议建议先到文稿末尾查看前两篇再来学习本篇文章）,相信大家一定都有了自己的理解,那么本文就开始真正走进Zookeeper底层源码的学习。俗话说授人以鱼不如授人以渔，今天我们就来分析下Zookeeper非常重要的一个环节–<strong>Leader选举</strong>。</p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>SID：服务器ID，用来标示ZooKeeper集群中的机器，每台机器不能重复，和myid的值一致</li><li>ZXID：事务ID</li><li>Vote: 选票，具体的数据结构后面有</li><li>Quorum：过半机器数</li><li>logicalclock：逻辑时钟（选举轮次），zk服务器Leader选举的轮次</li></ul><p><strong>服务器类型：</strong></p><p>在zk中，引入了Leader、Follwer和Observer三种角色。zk集群中的所有机器通过一个Leader选举过程来选定一台被称为Leader的机器，Leader服务器为客户端提供读和写服务。Follower和Observer都能够提供读服务，唯一的区别在于，Observer机器不参与Leader选举过程，也不参与写操作的过半写成功策略。因此，Observer存在的意义是：在不影响写性能的情况下提升集群的读性能。</p><p><strong>服务器状态：</strong></p><ul><li>LOOKING：Leader选举阶段；</li><li>FOLLOWING：Follower服务器和Leader保持同步状态；</li><li>LEADING：Leader服务器作为主进程领导状态；</li><li>OBSERVING：观察者状态，表明当前服务器是Observer，不参与投票；</li></ul><p>选举的目的就是选择出合适的Leader机器，由Leader机器决定事务性的Proposal处理过程，实现类两阶段提交协议（具体是ZAB协议）。</p><h2 id="二、启动选举主流程"><a href="#二、启动选举主流程" class="headerlink" title="二、启动选举主流程"></a>二、启动选举主流程</h2><p>在zk服务器集群启动过程中，经QuorumPeerMain中，不光会创建ZooKeeperServer对象，同时会生成<strong>QuorumPeer</strong>对象，代表了ZooKeeper集群中的一台机器。在整个机器运行期间，负责维护该机器的运行状态，同时会根据情况发起Leader选举。</p><p>QuorumPeer是一个独立的线程，维护着zk机器的状态。</p><p><img src="http://media.coderluo.top/img/1.png" alt=""></p><p>本次主要介绍的是选举相关的内容，之后的行文都是从startLeaderElection中衍生出来的。</p><h3 id="1-QuorumPeer维护集群机器状态"><a href="#1-QuorumPeer维护集群机器状态" class="headerlink" title="1. QuorumPeer维护集群机器状态"></a>1. QuorumPeer维护集群机器状态</h3><p>QuorumPeer的职责就是不断地检测当前的zk机器的状态，执行对应的逻辑，简单来说，就是根据服务所处的不同状态执行不同的逻辑。为了避免篇幅过长，影响阅读体验，删除了一部分逻辑后，代码如下：</p><p><img src="http://media.coderluo.top/img/2.png" alt=""></p><p>当机器处于<strong>LOOKING</strong>状态时，QuorumPeer会进行选举，但是具体的逻辑并不是由QuorumPeer来负责的，整体的投票过程独立出来了，从逻辑执行的角度看，整个过程设计到两个主要的环节：</p><ul><li>与其他的zk集群机器通信的过程</li><li>实现具体的选举算法</li></ul><p>QuorumPeer中默认使用的选举算法是FastLeaderElection。</p><h2 id="三、-选举过程中的整体架构"><a href="#三、-选举过程中的整体架构" class="headerlink" title="三、 选举过程中的整体架构"></a>三、 选举过程中的整体架构</h2><p>zk提拱多种选举算法 不过之前版本的都废弃掉了，一般默认使用FastLeaderElection 也就是在配置文件中设置 electorArg=3。在集群启动的过程中，QuorumPeer会根据配置实现不同的选举策略：</p><p><img src="http://media.coderluo.top/img/3.png" alt=""></p><h3 id="1-QuorumCnxManager"><a href="#1-QuorumCnxManager" class="headerlink" title="1. QuorumCnxManager"></a>1. QuorumCnxManager</h3><p>如果ClientCnxn是zk客户端中处理IO请求的管理器，QuorumCnxManager是zk集群间负责选举过程中网络IO的管理器，在每台服务器启动的时候，都会启动一个QuorumCnxManager，用来维持各台服务器之间的网络通信。</p><p><img src="http://media.coderluo.top/img/4.png" alt=""></p><p><strong>QuorumCnxManager</strong>、 <strong>Listener</strong>、 <strong>SendWorker</strong>、 <strong>RecvWorker</strong> 的分工很明确 准确的说 QuorumCnxManager这个类的职责也很明确，就是负责监听端口 发消息 读消息 其中：</p><ul><li>Listener 监听连接，维护与其他服务器的连接；</li><li>SendWorker 负责根据Listener保存的连接信息 向对应的server发送（投票）信息；</li><li>RecvWorker 获取其他server的（投票）信息 并存入队列；</li></ul><p>对于每一台zk机器，都需要建立一个TCP的端口监听，在QuorumCnxManager中交给Listener来处理，使用的是Socket的阻塞式IO（默认监听的端口是3888，是在config文件里面设置的）。在两两相互连接的过程中，<strong>为了避免两台机器之间重复地创建TCP连接</strong>，zk制定了连接的规则：<strong>只允许SID打的服务器主动和其他服务器建立连接</strong>。实现的方式也比较简单，在receiveConnection中，服务器会对比与自己建立连接的服务器的SID，判断是否接受请求，如果自己的SID更大，那么会断开连接，然后自己主动去和远程服务器建立连接。这段逻辑是由Listener来做的，且Listener独立线程。核心代码如下：</p><p><img src="http://media.coderluo.top/img/5.png" alt=""> </p><p>QuorumCnxManager这里只负责与其他server的信息交换 但不负责信息的生成与处理 数据的处理就要交给对应的选举算法进行处理了。</p><p>以上内容主要是建立各台zk服务器之间的连接通信过程，具体的选举策略zk抽象成了Election，主要分析的是<strong>FastLeaderElection</strong>方式（选举算法的核心部分）：</p><p><img src="http://media.coderluo.top/img/6.png" alt=""></p><h2 id="四、正式选举（FastLeaderElection选举算法）"><a href="#四、正式选举（FastLeaderElection选举算法）" class="headerlink" title="四、正式选举（FastLeaderElection选举算法）"></a>四、正式选举（FastLeaderElection选举算法）</h2><p>上面QuorumPeer在一直循环的检测当前主机的状态，如果是Looking状态，就会进行新一轮的选举，通过：</p><p> <code>setCurrentVote(makeLEStrategy().lookForLeader());</code></p><p>也就是FastLeaderElection的lookForLeader来进行leader选择,实现代码不多，不过有些地方还是不好理解的。。。</p><blockquote><p>talk is cheap, show me code!</p></blockquote><p>接下来，我们将org.apache.zookeeper.server.quorum.FastLeaderElection#lookForLeader 方法中的逻辑分为5个步骤来理解，这样我认为比直接看一整段代码效果好，如果你觉得这样看比较碎片，可以打开源码对照我们这里梳理的流程，在整体梳理几遍（看源码一定得多啃几遍，一遍基本上搞下不来）。</p><h3 id="1-创建选举对象，做选举前的初始化工作"><a href="#1-创建选举对象，做选举前的初始化工作" class="headerlink" title="1. 创建选举对象，做选举前的初始化工作"></a>1. 创建选举对象，做选举前的初始化工作</h3><p><img src="http://media.coderluo.top/img/leader-1.png" alt="leader-1"></p><h3 id="2-将自己作为新的Leader投出去（我选我）"><a href="#2-将自己作为新的Leader投出去（我选我）" class="headerlink" title="2. 将自己作为新的Leader投出去（我选我）"></a>2. 将自己作为新的Leader投出去（我选我）</h3><p><img src="http://media.coderluo.top/img/leader-2.png" alt=""></p><p>这里需要注意的是更新选票时获取的epoch是当前Server的epech，即上一轮leader的epoch；</p><p>着重看一下sendNotifications方法，这里是将当前机器的选票发送给所有参与投票的机器，不包括Observer：</p><p><img src="http://media.coderluo.top/img/leader-3.png" alt=""></p><h3 id="3-验证当前自己的选票与大家的选票谁更适合做Leader"><a href="#3-验证当前自己的选票与大家的选票谁更适合做Leader" class="headerlink" title="3. 验证当前自己的选票与大家的选票谁更适合做Leader"></a>3. 验证当前自己的选票与大家的选票谁更适合做Leader</h3><p><img src="http://media.coderluo.top/img/leader-4.png" alt=""></p><p>这里有一些点还是比较难以理解的，不过都已经标注了详细的注释，相信仔细看两遍一定可以理解的。</p><p>这里的 recvqueue 就是所有收到其它服务器投票后的票箱（带头结点的单向链表），recvqueue.poll 即取出第一票，这里我们看下poll方法做的操作：</p><p><img src="http://media.coderluo.top/img/leader-5.png" alt=""></p><p>一目了然，就是将链表头的next指针指向自己，即删除头节点，然后将head 指向之前头节点的next，也就是下一个元素，返回第一个元素的值，将当前第一个元素置为null，也就是新的头节点。</p><h3 id="4-判断本轮选举中否应该结束了"><a href="#4-判断本轮选举中否应该结束了" class="headerlink" title="4. 判断本轮选举中否应该结束了"></a>4. 判断本轮选举中否应该结束了</h3><p><img src="http://media.coderluo.top/img/leader-6.png" alt=""></p><p>到了这一步，开始遍历当前服务器收到的选票中是否已经有过半的参与者选择了当前服务器的选票（经过上面的步骤，当前服务器选票已经修改为最合适的），我们一起看下 <code>org.apache.zookeeper.server.quorum.FastLeaderElection#termPredicate</code> 方法:</p><p><img src="http://media.coderluo.top/img/leader-7.png" alt=""></p><p>如果当前选票没有过半，直接break继续取下一票进行判断，这个很好理解。</p><p>可是问题来了，如果已经过半了，后面的这个步骤为什么还要取下一票在和当前选票比看谁更适合呢？ </p><p>我们一起来看下面的代码：</p><p><img src="http://media.coderluo.top/img/leader-8.png" alt=""></p><p>我初次看的时候也是难以理解，为什么取出下一票后判断比当前选票更合适后要在将选票放回去，然后break呢？</p><p>上面的代码我已经写了注释，这个while 循环的目的是要遍历完票箱防止有比当前更合适的选票， 如果 n==null 则说明没有找到任何比当前“过半选票更合适的选票”，进行收尾工作，修改当前主机状态：</p><pre class=" language-java"><code class="language-java">proposedLeader <span class="token operator">==</span> self<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>        ServerState<span class="token punctuation">.</span>LEADING<span class="token operator">:</span> <span class="token function">learningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>然后清空队列，返回最终选票。</p><p>如果剩下的选票中有比自己更合适的则将其放回票箱，重新走一遍前面的流程，修改当前选票广播。</p><p>说明：票箱也就是当前接收选票的容器 recvset，本质是一个HashMap，key为投票者的serverId，所以收到多次投票也只是更新选票而已，设计很是巧妙呀！</p><h3 id="5-无需选举的情况"><a href="#5-无需选举的情况" class="headerlink" title="5. 无需选举的情况"></a>5. 无需选举的情况</h3><p><img src="http://media.coderluo.top/img/leader-9.png" alt=""></p><p>最后这块的代码虽然不多，可是却是最难理解的，上面的注释中分析了为什么选举过程中可以收到通知发送者状态为FOLLOWING, LEADING, OBSERVING 的情况，结合注释还得仔细的看几遍，其实就是为了处理下面这三种情况下的选举状态：</p><ol><li>新的Server(非Observer)加入到正常运行的集群</li><li>当Leader挂了，并不是所有follower都同时能够感知到leader挂了，先感知到的server会发送通知给其它server，但由于其它server还未感知到，所以它们发送给这个server的通知状态就是FOLLOWING</li><li>本轮选举中其它Server已经选举出了新的leader，但还没有通知到当前server，这些已经知道leader选举完毕的server向该server发送的通知就是LEADING或FOLLOWING</li></ol><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>以上就是zk的默认选举流程，按照ZAB协议的两种状态分析：</p><ul><li>初始化的时候，处于同一轮次进行投票直到投票选择出一个Leader</li><li>崩溃恢复阶段：<ol><li>Leader服务器挂了，那么经历的和初始化流程类似的过程，选择Leader</li><li>Follower服务器挂了，那么自己在执行选举的过程中，会收到其他服务器给的Leader选票信息（对应上文无需选举情况中的分支代码），也可以确定Leader所属</li></ol></li></ul><blockquote><p>本篇文章主要介绍了Zk leader选举过程中的代码逻辑，包括机器宕机重启以及集群初始化时QuorumPeer 都会检测到机器的状态为LOOKING，然后调用 FastLeaderElection 的 lookForLeader 方法进行 leader选举。 这块的代码虽然不多，可是理解起来还是有一定的难读的，建议大家结合本文多度几遍，加深印象。</p></blockquote><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTE4NTg1OA==&amp;mid=2247483685&amp;idx=2&amp;sn=11c01a7b93de8a31528a5f36be754a7f&amp;chksm=9f999c08a8ee151ec8678cdd588be7d45637890f90ee44dd52b3d15d2b621fadacd81c0da3ca&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">初探|Zookeeper基础之Paxos算法详解（一）</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTE4NTg1OA==&amp;mid=2247483685&amp;idx=1&amp;sn=1315bf46d6bf5be74b8f6006ddd2a7d2&amp;chksm=9f999c08a8ee151e0f26e2d4332716385a63a70089947e49dcb2113be7e33d5f58b80e67b39b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Zookeeper实现之Zab协议详解(二)</a></li></ul><p>如果您对于源码的阅读有疑问，可以公众号给我留言，每条留言<strong>都</strong>将得到<strong>认真</strong>回复，一起探讨学习。</p><p>后续持续推出Java、分布式、微服务、数据库等系列的文章，欢迎大家关注我的公众号，一起交流。</p><p><img src="https://oscimg.oschina.net/oscnet/2ce2160547f3619832c8ae314d478077cdb.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper深度学习1-Paxos算法详解</title>
      <link href="/2019/09/05/zookeeper/zookeeper-shen-du-xue-xi-1-paxos-suan-fa-xiang-jie/"/>
      <url>/2019/09/05/zookeeper/zookeeper-shen-du-xue-xi-1-paxos-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p><em>本片文章将开启对分布式协调服务zk的学习，目前规划是从理论基础开始逐步到源码解析，深入学习这个在分布式系统中起着至关作用的组件。</em></p><p>对于 zk 理论的学习，最重要也是最难的知识点就是 Paxos 算法。所以我们首先学习 Paxos 算法。</p><hr><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><blockquote><p>Paxos 算法是莱斯利·兰伯特(Leslie Lamport)1990 年提出的一种基于消息传递的、具有高 容错性的一致性算法。Google Chubby 的作者 Mike Burrows 说过，世上只有一种一致性算法， 那就是 Paxos，所有其他一致性算法都是 Paxos 算法的不完整版。Paxos 算法是一种公认的晦 涩难懂的算法，并且工程实现上也具有很大难度。较有名的 Paxos 工程实现有 Google Chubby、 ZAB、微信的 PhxPaxos 等</p></blockquote><p>Paxos 算法是用于解决什么问题的呢? Paxos 算法要解决的问题是，在分布式系统中如何 就某个决议达成一致。</p><h2 id="Paxos与拜占庭将军问题"><a href="#Paxos与拜占庭将军问题" class="headerlink" title="Paxos与拜占庭将军问题"></a>Paxos与拜占庭将军问题</h2><blockquote><p>拜占庭将军问题是由 Paxos 算法作者莱斯利·兰伯特提出的点对点通信中的基本问题。该 问题要说明的含义是，<font color="red">在不可靠信道上试图通过消息传递的方式达到一致性是不可能的</font>。所 以，Paxos 算法的前提是<font color="red">不存在拜占庭将军问题</font>，即信道是安全的、可靠的，集群节点间传 递的消息是不会被篡改的。</p></blockquote><p>一般情况下，分布式系统中各个节点间采用两种通讯模型:<strong>共享内存(Shared Memory)</strong>、<strong>消息传递(Messages Passing)</strong>。而 Paxos 是基于消息传递通讯模型的。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><h3 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h3><p>在 Paxos 算法中有三种角色，分别具有三种不同的行为。但很多时候，一个进程可能同 时充当着多种角色。 </p><ul><li>Proposer:提案者，提出提案（Proposal）；</li><li>Acceptor:表决者；</li><li>Learner:学习者(同步者，即Proposer决议形成，将所有形成的决议发送给Learners)</li></ul><h3 id="Paxos算法一致性"><a href="#Paxos算法一致性" class="headerlink" title="Paxos算法一致性"></a>Paxos算法一致性</h3><p>Paxos 算法的一致性主要体现在以下几点:</p><ul><li>每个提案者在提出提案时都会首先获取到一个具有全局唯一性的、递增的提案编号N，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案。</li><li>每个表决者在accept某提案后，会将该提案的编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个编号最大的提案，其编号假设为 maxN。每个表决者仅会 accept 编号大于自己本地 maxN 的提案。</li><li>在众多提案中最终只能有一个提案被选定。</li><li>一旦一个提案被选定，则其它服务器会主动同步(Learn)该提案到本地。</li><li>没有提案被提出则不会有提案被选定。</li></ul><h3 id="Paxos算法流程"><a href="#Paxos算法流程" class="headerlink" title="Paxos算法流程"></a>Paxos算法流程</h3><p>Paxos 算法的执行过程划分为两个阶段:<strong>准备阶段 prepare</strong> 与<strong>接受阶段 accept</strong>。Ps:Learn阶段之前决议已经形成。</p><p>由于Paxos算法是晦涩难懂的，这里我将以自己的理解来做整个描述，虽然可能在严谨性上会差强人意，但是可读性会提高，希望可以给大家更轻松的阅读体验。</p><h4 id="A、Prepare阶段"><a href="#A、Prepare阶段" class="headerlink" title="A、Prepare阶段"></a>A、Prepare阶段</h4><ol><li>提案者(Proposer)准备提交一个编号为 N 的提议，于是其首先向所有表决者(Acceptor)发 送 prepare(N)请求，用于试探集群是否支持该编号的提议。 如果这里不好理解我们可以试图理解为提议者拿着钞票去贿赂“表决者（Accept）”</li><li>每个表决者（Acceptor）都保存者当前贿赂自己的最大金额数，即（maxN），当每个表决者接收到贿赂自己的提议时，会比较贿赂金额与maxN的值。有以下几种情况：<ol><li>若 N 小于 maxN，则说明该提议已过时（钱少不接受），当前表决者采取不回应或回应 Error 的方 式来拒绝该 prepare 请求；</li><li>若 N 大于 maxN，则说明该提议是可以接受的（毕竟谁给的钱多听谁的），当前表决者会首先将该 N（当前贿赂金额） 记录下来， 并将其曾经已经 accept 的编号最大的提案 Proposal(myid,maxN,value)反馈给提案者， 以向提案者展示自己支持的提案意愿。其中第一个参数 myid 表示表决者 Acceptor 的标识 id，第二个参数表示其曾接受的提案的最大编号 maxN（前任领导贿赂的金额），第三个参数表示该 提案的真正内容 value（前任领导提议的内容）。当然，若当前表决者还未曾 accept 过任何提议，则会将 Proposal(myid,null,null)反馈给提案者。</li><li>在 prepare 阶段 N 不可能等于 maxN。这是由 N 的生成机制决定的。要获得 N 的值， 其必定会在原来数值的基础上采用同步锁方式增一。 </li></ol></li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ee1de1blj30qo0hg757.jpg" alt=""></p><blockquote><p>这里需要说明下，为什么在表决者（Acceptor）判断贿赂金额大于当前保存的最大金额时会将前任已经保存的金额和提案内容返回给提案者，这是因为提案者（Proposer），在收到表决者的答复后，需要判断谁是最有钱的提案者，便推举它为领袖 (修改自己的提案)。</p></blockquote><h4 id="B、Accept阶段"><a href="#B、Accept阶段" class="headerlink" title="B、Accept阶段"></a>B、Accept阶段</h4><ol><li>当提案者(Proposer)发出 prepare(N)后，若收到了超过半数的表决者(Accepter)的反馈， 那么该提案者就会将其真正的提案 Proposal(myid,N,value)发送给所有的表决者。</li><li>当表决者(Acceptor)接收到提案者发送的 Proposal(myid,N,value)提案后，会再次拿出自己 曾经 accept 过的提议中的最大编号 maxN，或曾经记录下的 prepare 的最大编号，让 N 与它们进行比较，若 N <strong>大于等于</strong>这两个编号，则当前表决者 accept 该提案，并反馈给 提案者。若 N 小于这两个编号，则表决者采取不回应或回应 Error 的方式来拒绝该提议。</li><li>若提案者没有接收到超过半数的表决者的 accept 反馈（中间有别人以更多的金额贿赂了它），则有两种可能的结果产生。一 是放弃该提案，不再提出；二是重新进入 prepare 阶段，递增提案号，重新提出 prepare 请求。</li><li>若提案者接收到的反馈数量超过了半数，则其会向外广播两类信息：<ol><li>向曾 accept 其提案的表决者发送“可执行数据同步信号”，即让它们执行其曾接收到的提案；</li><li>向未曾向其发送 accept 反馈的表决者发送“提案 + 可执行数据同步信号”，即让 它们接受到该提案后马上执行。</li></ol></li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ee1h8hxej30j80ihmym.jpg" alt=""></p><p>上述的过程中，如果某一个提议收到了大多数的表决者（Acceptor）的响应后（提案者（Proposal）中的N必须大于当前maxN才会响应），则提案通过，向所有表决者以及leaner发送同步数据，达成数据一致性。</p><p>当然上面只是简单的描述，真是的算法场景更复杂，所有提议者，决策者身份信息都是交叉的，如果提议者、接受者的数量是4个,5个。。。但是你按照上面的思路进行推演，最终会发现最终是唯一一个提议获取多数票而胜出，从而其他提议者和决策者同步此提议。</p><h2 id="活锁问题"><a href="#活锁问题" class="headerlink" title="活锁问题"></a>活锁问题</h2><p>上面的流程可能会引发活锁问题，那么什么是活锁呢？  </p><blockquote><p>活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程。处于活锁的实体是在不断的改变状态，活锁有可能自行解开。</p></blockquote><p>那么上面的行为是怎么会引发活锁呢？接下来我们一起来分析下：</p><p>在整个选举过程中，每个人谁先来谁后到，“接受者”什么时间能够接到“提议者”的信息，是完全不可控的；</p><p>假设，第一个提案者A（Proposal）已经成功过了prepare阶段，准备向Acceptors广播发送Accept时，有一个更有钱土豪提案者B也向决议者（Acceptors）广播了prepare请求并在A的accept请求到之前发送给了决议者，这时毫无疑问，决议者会接收该请求，并记录在册。这时候，A的accept请求姗姗来迟，决议者对比此proposal的贿赂金额已经小于当前记录的prepare最大编号，因此不响应给提议者A，则提议者A收到的响应为过半，此提案废弃。这时它又用大于Proposer A的贿赂金额重新发起 preapre广播请求，这时提议者B的accept请求还没有到达决议者（Acceptors），因此Acceptor也接受了该prepare请求，将其记录在案，在之后提议者B发出的accept请求到达，决议者发现贿赂金额已经小于当前prepare的最大贿赂金额，因此拒绝响应，这样就会形成活锁问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章故事讲到这里就基本上结束了，下面我们来总结一下，其实Paxos算法主要包括两个阶段：</p><ol><li>prepare阶段，这个阶段主要是准备一个编号为N的提案，首先向所有决议者（Acceptor）发送prepare请求，用于试探是否支持该编号的提议。</li><li>accept阶段，当一阶段提议收到了超过半数的响应，则开始正式下发提案内容proposal，如果过半则提案提交成功，广播给所有learner。</li></ol><p>注意：编号（贿赂金额）很重要，无论在哪个阶段，编号（贿赂金额）小的，都会被鄙视（被拒绝）；</p><p>今天的分享就到这里了，这也是我学习Paxos算法过程中的一些心得，希望对初学者有些启发。</p><p>后续我们对继续深入学习Zookeeper之<strong>Zab协议（Paxos算法的工业实现）</strong>，今天提到的活锁问题，也会得到相应的解决，敬请期待。</p><p>系列文章：</p><ul><li><a href="http://coderluo.top/2019/09/08/zookeeper/zookeeper-shen-du-xue-xi-2-zab-xie-yi-xiang-jie/">Zookeeper深度学习2-Zab协议详解</a></li><li><a href="http://coderluo.top/2019/09/08/zookeeper/zookeeper-shen-du-xue-xi-3-yuan-ma-fen-xi-leader-xuan-ju/">Zookeeper深度学习3-源码分析-Leader选举</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
            <tag> Paxos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP-1:计算机系统漫游</title>
      <link href="/2019/08/30/csapp/csapp-1-ji-suan-ji-xi-tong-man-you/"/>
      <url>/2019/08/30/csapp/csapp-1-ji-suan-ji-xi-tong-man-you/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本周开始了CSAPP的读书计划，规划已久，终于要开动了。之前自己也零散看过，不得不说这本书有难度都没坚持下去，这次跟着码农翻身小伙伴们一起打卡这本书。</p></blockquote><p>CSAPP这本书不用多说绝对经典中的经典，如果想成为一名知道计算机硬件和软件如何工作，了解其如何影响程序的正确性和性能的程序员，那么一定得看啊。</p><blockquote><p>如果能完全理解本书讲解的计算机系统以及它对应用程序的影响，那么恭喜你，你走上了一条为数不多的大牛道路。</p></blockquote><p>在开始之前,我们先看一个最常见的程序:</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello,world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>本文就从上面这个最简单的hello程序展开,沿着它的生命周期展开学习.</p><h2 id="程序的保存格式"><a href="#程序的保存格式" class="headerlink" title="程序的保存格式"></a>程序的保存格式</h2><p>上面的hello程序其实就是一个由值 0 和 1 组成的位（即比特）序列，8个位成一组，称为字节。我们输入文本hello.c文件中的字符即用每个字节来表示（大部分计算机系统都是用ASCII标准来表示字符，即把字节转为整数值）。</p><p><strong>总结： 信息=位+上下文</strong></p><h2 id="程序是如何运行的"><a href="#程序是如何运行的" class="headerlink" title="程序是如何运行的"></a>程序是如何运行的</h2><p>hello程序的诞生使用C语言来编写的，好处是人可以读懂，但是为了在系统上运行，还是得转化为一系列低级的机器语言指令。</p><p>在Unix系统上，从源文件到目标文件的转化得靠编译器， 下面记录编译过程：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/49y1m.png" alt=""></p><ol><li>hello.c需要经过预处理器读取系统头文件内容并且插入到程序文本中得到一个新的C程序，一般以.i作为扩展名；</li><li>然后编译器将文本文件hello.i 翻译成汇编语言文本文件hello.s</li><li>接下来，就该汇编器登场，将汇编语言翻译成机器语言指令，并保存到hello.o文件中，此时它是一个二进制文件了</li><li>最后链接阶段，将程序中调用的c标准库的函数合并到我们的hello.o程序中，结果就是一个可执行文件，可以被加载到内存中，由系统执行。</li></ol><h3 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h3><p>要真正了解程序时如何运行的，首先要对系统的硬件组成有一个了解：</p><ol><li><p>总线：贯穿整个系统的电子管道，可以理解为所有的数据设备以及系统之间的数据流转都要接到总线上。</p></li><li><p>I/O设备：系统与外部世界的联系通道；比如键盘、鼠标、磁盘、显示器等；</p><p>所有的I/O设置都要通过一个控制器或者适配器与I/O总线相连；</p></li><li><p>主存：也就是我们常说的内存，这是一个临时存储设备，在处理器执行程序时，用来存放程序和处理的数据；</p></li><li><p>处理器：也就是我们常说的CPU，是解释存储在主存中指令的引擎；其核心是一个大小为一个字（定长的字节，根据系统不同确定）的寄存器，称为程序计数器（PC）。在程序运行的过程中，PC都是指向主存中的一条机器语言指令。</p><p>从系统通电开始，直到系统断电，处理器一直在不断的执行PC指向的指令，在更新PC，使其指向下一条指令；</p><p>下面列举几个CPU在指令要求下可能执行的操作：</p><ul><li>加载：从主存复制一个字到寄存器，已覆盖原有寄存器的内容；</li><li>存储：从寄存器复制一个字到主存的某个位置，以覆盖这个位置的原有值；</li><li>操作：把两个寄存器的内容复制到ALU（算数/逻辑单元）,ALU对这两个字做算数运算，并将结果存放到一个寄存器中覆盖原有的内容；</li><li>跳转：从指令本身抽取一个字，并将这个字复制到PC中，以覆盖PC中原来的值；</li></ul><blockquote><p>处理器看上去是它的指令集架构的简单实现，但是现代处理器采用非常复杂的机制来加速程序的运行。因此我们在理解的时候要将处理器的<strong>指令集架构</strong> 和处理器的 <strong>微体系结构</strong>分来：指令集架构描述的是每条机器代码指令的效果；微体系结构描述的是处理器的实现；</p></blockquote></li></ol><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>当我们在执行 <code>./hello</code> 后，其实发生的过程是：</p><p>刚开始，shell程序执行它的指令，等待我们输入一个命令，当我们输入<code>./hello</code> 后，shell程序将字符读入寄存器，在把它存放到内存中；</p><p>当你在敲回车时，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行文件，将目前文件的代码和数据复制到主存。<strong>注：利用直接存储器（DMA）技术，数据可以不到处理器直接从磁盘到主存。</strong></p><p>一旦加载到内存中，处理器就开始执行程序的main机器指令，这些指令将“hello,world\n” 字符串中字节从主存复制到寄存器文件。再从寄存器文件复制到显示设备，最终展示在屏幕上。</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/zyak9.png" alt=""></p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>​    从上面的例子，我们可以总结出，hello程序经历了从开始在磁盘上，加载时被复制到主存，处理器运行时又从主存复制到处理器，最后又从处理器复制到显示器。</p><p>​    这里从我们程序员角度讲，这些复制就是开销，那么问题来了，如何减小开销提高处理器效率呢？？？</p><p>从机械原理角度来看，存储设备越大运行越慢；处理器读磁盘比读内存开销大1000万倍，而寄存器文件的读取速度又比内存块几乎100倍，加快处理器的运行速度比加快主存运行速度要容器的多。</p><p>​    针对处理器与主存之间的差异，系统设计采用了更小更快的存储设备，称之为高速缓存，存放处理器近期可能会需要的信息。这个其实和我们平时开发程序是一样的，采用多级缓存，存放热点数据，提高系统处理能力。 这里的原理是利用程序具有访问局部区域里的数据和代码的趋势，所以高速缓存中存放了可能经常访问的数据，这样大部分操作就能在告诉缓存中完成。</p><p>请看下面的存储器层次的结构，相信你会一目了然：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/zwczg.png" alt=""></p><p>如图所示，上一层存储器是下一层的高速缓存。</p><h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>我们写的程序，没有直接访问键盘、显示器、磁盘等硬件，而是依赖操作系统提供的服务，所以可以把操作系统看成是应用程序和硬件之间一层软件。</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/84g1c.png" alt=""></p><p>操作系统有两大功能：</p><ol><li>防止硬件被滥用；</li><li>对应用程序屏蔽底层复杂而通常又大不相同的硬件设备，提供简单一致的机制；</li></ol><p>操作系统通常抽象出几个概念：进程、虚拟内存、文件；</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统对一个正在运行的应用程序的抽象，一个系统可以同时运行多个进程。</p><p>单核处理器一个时刻只能执行一个程序，而目前的多核处理器能同时执行多个程序。无论单核还是多核，一个CPU看上去都是在并发执行多个进程，这是通过处理器在进程间切换来实现的，这种切换被称为 <strong>上下文切换</strong>；</p><p>进程之间的切换是由操作系统内核管理的，内核是操作系统常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。 注意，内核不是一个独立的进程，它是系统管理所有进程所用代码和数据结构的集合。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程实际上是由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p><p>优点：比进程之间更容易共享数据；一般来讲也比进程更高效；</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>这是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在单独使用主存，每个进程看到的内存都是一致的，称为虚拟地址空间，如下图所示，地址是从小往上增大的：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/d3sxd.png" alt=""></p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件就是字节序列，所有的I/O设备，甚至网络都可以看成是文件；</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>多核处理器是将多个CPU集成到一个集成电路芯片上。多核处理器组织架构如下：</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/sx3es.png" alt=""></p><p>超线程：称为同时多线程，允许一个CPU同时执行多个并发流的技术。Intel Core i7 处理器可以让每个核执行两个线程。</p><h3 id="计算机系统中的抽象"><a href="#计算机系统中的抽象" class="headerlink" title="计算机系统中的抽象"></a>计算机系统中的抽象</h3><p>在处理里，指令集架构提供了对实际处理器硬件的抽象，使用这个抽象，机器代码表现的好像运行在一个一次只执行一条指令的处理器上。不管底层多复杂精细，哪怕可以并发的执行多条指令，担又总是与那个简单有序的模型保持一致。只要模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。这种抽象思想简直太重要了，在整个计算机科学中也随处可见，比如java类的生命和C语言的函数原型，以及计算机网络的分层。</p><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/i7aak.png" alt=""></p><p>看了这上面的图可以总结为：</p><ol><li>文件是对I/O设置的抽象；</li><li>虚拟内存是对主存和磁盘的抽象；</li><li>进程是对处理器、主存和I/O设备的抽象；</li></ol><p>至此，本章的学习就结束了，主要对计算机系统的组成和程序运行有了大框架的认知，后续继续进行深入学习。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建Zookeeper集群</title>
      <link href="/2019/08/28/zookeeper/docker-da-jian-zookeeper-ji-qun/"/>
      <url>/2019/08/28/zookeeper/docker-da-jian-zookeeper-ji-qun/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大家好，我是程序员小罗，这是我的技术学习笔记。</p></blockquote><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于最近在学习zookeeper的原理，所以需要在安装一个集群来实验一些特性加深理解。</p><p>但是问题来了，我们作为个人学习者，要搭建集群又没有那么多机器，要么就是搭建伪集群，或者就是需要安装一个虚拟机软件（比如vmWare），装多个虚拟机。 这两种方法我之前都试过，都不太理想，一个需要改端口，一种需要安装很多虚拟机，而且换了电脑也不好迁移。每次都得搞重复的配置，实现是太令人烦恼了；</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>综上，上述的痛点，都不是我们愿意做的。接下来，就要介绍今天我用的神器：<code>Docker</code> 。</p><blockquote><p> 使用Docker 基本上不用我们装环境之类的配置，比如安装 jdk。现在我们直接可以从镜像仓库拉别人制作好的镜像，简直不要太方便，直接运行即可。</p></blockquote><p><strong>今天我要搭建的是一个由四台 zk 构成的 zk 集群，其中一台为 Leader，两台 Follower，一台 Observer。</strong></p><p><code>talk is cheap,show me your code</code>, 接着往下看吧！</p><hr><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>不管你现在用的windows 还是linux 系统，首先你需要安装好Docker环境。 这里就不在叙述了，官网下载安装即可。</p><p>如果对Docker 基本操作不熟悉的话，可以看我之前写的 <a href="https://www.jianshu.com/p/251e55d9f9b3" target="_blank" rel="noopener">Docker入门（镜像、容器、仓库）</a></p><p>PS: 本次所制作的镜像，可以直接保存到自己的私服，以后随时随地直接拉取运行即可。<strong>一次制作，到处运行</strong>。</p><p>私服的搭建也可以看我之前写的Docker入门。</p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p><code>docker pull zookeeper:3.4.11</code> 这里我选择了3.4.11 版本。</p><h3 id="设置docker固定ip"><a href="#设置docker固定ip" class="headerlink" title="设置docker固定ip"></a>设置docker固定ip</h3><p>因为我们要搭建的是集群环境，所以ip地址必须固定，因此需要自定义一种网络类型。</p><h4 id="创建自定义网络类型，并且指定网段"><a href="#创建自定义网络类型，并且指定网段" class="headerlink" title="创建自定义网络类型，并且指定网段"></a>创建自定义网络类型，并且指定网段</h4><p><code>sudo docker network create --subnet=192.168.0.0/24 staticnet</code></p><p>通过<code>docker network ls</code>可以查看到网络类型中多了一个 staticnet</p><h3 id="使用新的网络类型创建并启动容器"><a href="#使用新的网络类型创建并启动容器" class="headerlink" title="使用新的网络类型创建并启动容器"></a>使用新的网络类型创建并启动容器</h3><pre class=" language-shell"><code class="language-shell">chong@L MINGW64 ~$ docker run --name zookeeper-1 --restart always --net staticnet --ip 192.168.0.10 -d zookeeper:3.4.1161a331b2584b6ef949e2183892c5a73a2e214b7071d4879993f7cbba41c836ed</code></pre><p>通过<code>docker inspect</code>可以查看容器 ip为<code>192.168.0.10</code>，关闭容器并重启，发现容器ip并未发生改变。</p><h3 id="进入容器进行配置"><a href="#进入容器进行配置" class="headerlink" title="进入容器进行配置"></a>进入容器进行配置</h3><p>由于容器在后台运行，因此我们需要进入容器，有三种方式，有兴趣的可以看我之前写的 <a href="https://www.jianshu.com/p/251e55d9f9b3" target="_blank" rel="noopener">Docker入门（镜像、容器、仓库）</a></p><pre class=" language-shell"><code class="language-shell">$ docker exec -ti 61a bash   # 61a为容器id</code></pre><p>登入后，我们只需要做2件事：</p><ol><li><strong>修改zoo.cfg</strong></li></ol><p>在 zoo.cfg 文件中添加 zk 集群节点列表</p><pre class=" language-shell"><code class="language-shell">bash-4.4# vi /conf/zoo.cfgclientPort=2181dataDir=/datadataLogDir=/datalogtickTime=2000initLimit=5syncLimit=2maxClientCnxns=60server.1=192.168.0.10:2888:3888server.2=192.168.0.11:2888:3888server.3=192.168.0.12:2888:3888server.4=192.168.0.13:2888:3888:observer</code></pre><ol start="2"><li><strong>创建</strong> <strong>myid</strong> <strong>文件</strong></li></ol><p>在一步的zoo.cfg文件中我们可以看到dataDir的路径，在/data 目录中创建表示当前主机编号的 myid 文件。该主机编号要与 zoo.cfg 文件中设置的编号一致。</p><pre class=" language-shell"><code class="language-shell">bash-4.4# echo 1 > /data/myid</code></pre><h3 id="保存修改后的镜像"><a href="#保存修改后的镜像" class="headerlink" title="保存修改后的镜像"></a>保存修改后的镜像</h3><p>因为我们上面对正在运行的容器做了三点修改，这也正是我们需要的集群配置，所以我们要将这个容器制作成镜像,如下操作：</p><pre class=" language-shell"><code class="language-shell">$ docker commit -m "create zk1" -a "coderluo" 61a zookeeper-1:3.4.11sha256:455b27d32c83365790b7b6eff7d58021556858390d28d27b07aca206e83c507cchong@L MINGW64 ~$ docker imagesREPOSITORY                   TAG                 IMAGE ID            CREATED             SIZEzookeeper-1                  3.4.11              455b27d32c83        8 seconds ago       146MB39.108.186.135:5000/ubuntu   v1                  a2a15febcdf3        13 days ago         64.2MBzookeeper                    3.4.11              56d414270ae3        19 months ago       146MB</code></pre><p>使用<code>docekr commit</code> 进行基于已有的镜像进行创建，我的上一篇Docker入门中也有写。然后通过<code>docker images</code> 查看到zookeeper-1 这个镜像已经存在了。</p><p>到这里一台镜像已经制作好了，接下来就是一样的事情重复干几遍:</p><ul><li>进入容器</li><li>修改myid</li><li>保存修改制作为新镜像</li></ul><p><strong>查询容器id</strong></p><pre class=" language-shell"><code class="language-shell">$ docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                          NAMES61a331b2584b        zookeeper:3.4.11    "/docker-entrypoint.…"   About an hour ago   Up 12 minutes       2181/tcp, 2888/tcp, 3888/tcp   zookeeper-1</code></pre><p><strong>进入容器执行修改(第2,3台都执行此操作)：</strong></p><pre class=" language-shell"><code class="language-shell">$ docker exec -ti 61a bashbash-4.4# echo 2 > /data/myidbash-4.4# cat /data/myid2bash-4.4# exitexit</code></pre><p><strong>创建新的镜像(第2,3台都执行此操作)：</strong></p><pre class=" language-shell"><code class="language-shell">$ docker commit -m "create zookeeper-2" -a "coderluo" 61a zookeeper-2:3.4.11sha256:c775aff13fd3b2fc30066f6fc5f8a5ee429be3052b790c8e02cf74b5e4bf71e9</code></pre><p>完成后，这里要注意，第四台主机因为我们要让他作为Observer，所以他需要在zoo.cfg中增加一行配置：</p><p> <code>peerType=observer</code></p><p><img src="http://media.coderluo.top/img/1.png%3F1" alt="1"></p><p>然后在执行上面和第2,3台机器一样的操作。</p><p>最后我们查看当前所有的镜像，不出意外的话下图展示的你也都有了：</p><p><img src="http://media.coderluo.top/zk/2.png" alt="2"></p><p>到这里，今天的学习就要接近尾声了，最后一步</p><h3 id="依次启动4台zookeeper实例"><a href="#依次启动4台zookeeper实例" class="headerlink" title="依次启动4台zookeeper实例"></a>依次启动4台zookeeper实例</h3><p>直接按照我下面的命令一次执行即可：</p><pre class=" language-shell"><code class="language-shell">chong@L MINGW64 ~$  docker run --name zookeeper-1 --restart always --net staticnet --ip 192.168.0.10 -d zookeeper-1:3.4.11 #第一台35acd4f798c8154047f30af184145d8b4124ec8a4e8e4a549db0d333a1c33785chong@L MINGW64 ~$  docker run --name zookeeper-2 --restart always --net staticnet --ip 192.168.0.11 -d zookeeper-2:3.4.11 #第二台7ef30c809183dc223e42e891880ad8c85381fac11d15da5c0455400b915c77bbchong@L MINGW64 ~$  docker run --name zookeeper-3 --restart always --net staticnet --ip 192.168.0.12 -d zookeeper-3:3.4.11 #第三台f138451dd21ce5217eb6e4472116b3ffa32e9ea2afbcaae44ee4d633040299f9chong@L MINGW64 ~$  docker run --name zookeeper-4 --restart always --net staticnet --ip 192.168.0.13 -d zookeeper-4:3.4.11 #第四台c662d3438db74414c9b0178bc756b6cf96cd0458cbc226e8854da4a06337d656</code></pre><p>查看运行状态：</p><pre class=" language-shell"><code class="language-shell">$ docker ps -aCONTAINER ID        IMAGE                COMMAND                  CREATED              STATUS              PORTS                          NAMESc662d3438db7        zookeeper-4:3.4.11   "/docker-entrypoint.…"   6 seconds ago        Up 4 seconds        2181/tcp, 2888/tcp, 3888/tcp   zookeeper-4f138451dd21c        zookeeper-3:3.4.11   "/docker-entrypoint.…"   24 seconds ago       Up 23 seconds       2181/tcp, 2888/tcp, 3888/tcp   zookeeper-37ef30c809183        zookeeper-2:3.4.11   "/docker-entrypoint.…"   41 seconds ago       Up 39 seconds       2181/tcp, 2888/tcp, 3888/tcp   zookeeper-235acd4f798c8        zookeeper-1:3.4.11   "/docker-entrypoint.…"   About a minute ago   Up About a minute   2181/tcp, 2888/tcp, 3888/tcp   zookeeper-1</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此我们今天要搭建的四台zk实例组成的集群已经搞定了，有没有感觉到有了Docker 简直是神奇啊，只有亲身体会下才能感觉他的便利。</p><p>欢迎在留言区讨论，今天就到这里啦，可以愉快的学习第zk的底层原理了。</p><p>Docker 入门基础知识，可以看我整理的这篇文章：</p><p><a href="https://www.jianshu.com/p/251e55d9f9b3" target="_blank" rel="noopener">Docker入门（镜像、容器、仓库)</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="/2019/08/17/docker/docker-ru-men/"/>
      <url>/2019/08/17/docker/docker-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><blockquote><p>镜像是Docker运行容器的前提</p></blockquote><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><pre class=" language-shell"><code class="language-shell">docker pull NAME[:TAG] // 不指定TAG，默认选择latest标签</code></pre><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><pre class=" language-shell"><code class="language-shell">docekr run -t -i ubuntu /bin/bash</code></pre><h3 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h3><pre class=" language-shell"><code class="language-shell">docker images</code></pre><ul><li>添加镜像标签</li></ul><pre class=" language-shell"><code class="language-shell">docker tag ubuntu:latest my/ubuntu:latest</code></pre><ul><li>查看镜像详细信息</li></ul><pre class=" language-shell"><code class="language-shell">docker inspect 镜像iddocker inspect -f {{".Architecture"}} id  // 查询某一项内容</code></pre><h3 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h3><pre><code>docker search TERM--automated=false 仅展示自动创建的镜像--no-trunc=false 输出信息不截断显示-s=0 仅显示评价为指定星级以上的镜像</code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><pre class=" language-shell"><code class="language-shell">docker rmi IMAGE[IMAGE...]  其中IMAGE可以为标签或者id</code></pre><ul><li>删除正在运行的镜像</li></ul><pre class=" language-shell"><code class="language-shell">docker rmi -f ubuntu 强制删除（不建议）推荐：1. 删除容器；2. 再用id删除镜像docker rm id  docker rmi ubuntu </code></pre><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><ul><li>基于已有镜像创建</li></ul><pre class=" language-shell"><code class="language-shell">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]选项包括：-a,--author="" 作者信息-m,--message="" 提交信息-p,--pause=true 提交时暂停容器运行</code></pre><p>下面是一个展示：</p><pre class=" language-shell"><code class="language-shell">$ winpty docker run -ti ubuntu bashroot@39b31ce63c14:/# touch testroot@39b31ce63c14:/# exit# 查看容器id$ docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES39b31ce63c14        ubuntu              "bash"              12 minutes ago      Exited (0) 11 minutes ago                       friendly_chebyshev$ docker commit -m "added a new file" -a "coderluo" 39b test:coderluosha256:489150941c65c552268ddacd10d9fe05c01e30c8c3bd111e4217d727e8f724c4</code></pre><ul><li>基于本地模板导入</li></ul><p>可以直接从一个操作系统模板文件导入一个镜像，推荐使用OpenVZ提供的模板来创建。下载地址为：</p><p><a href="https://wiki.openvz.org/Download/template/precreated" target="_blank" rel="noopener">https://wiki.openvz.org/Download/template/precreated</a></p><p>比如我下载了一个ubuntu，可以使用如下命令导入：</p><pre class=" language-shell"><code class="language-shell">[root@izwz909ewdz83smewux7a7z ~]# cat ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04sha256:57a7c0bb864c4185d5d9d6eb6af24820595482b9df956adec5fde8d16aa9cb7c[root@izwz909ewdz83smewux7a7z ~]# docker images</code></pre><ul><li>基于Dockerfile创建</li></ul><h3 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h3><blockquote><p>可以使用 docker save 和 docker load 命令来存出和载入镜像</p></blockquote><h4 id="存出镜像"><a href="#存出镜像" class="headerlink" title="存出镜像"></a>存出镜像</h4><pre class=" language-shell"><code class="language-shell">$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEmyubuntu            coderluo            489150941c65        About an hour ago   64.2MBubuntu              latest              a2a15febcdf3        43 hours ago        64.2MBubuntu              14.04               271ca7812183        3 months ago        188MBchong@L MINGW64 ~$ docker save -o myubuntu_14.04.tar myubuntu:coderluo</code></pre><h4 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h4><pre class=" language-shell"><code class="language-shell">chong@L MINGW64 ~$ docker load &lt; myubuntu_14.04.tar</code></pre><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><pre class=" language-shell"><code class="language-shell">docker push NAME[:TAG]</code></pre><hr><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><blockquote><p>容器就是镜像的一个运行实例,它带有额外的可写文件层</p></blockquote><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><h4 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h4><p>使用 docker create 创建容器后市处于停止状态,可以使用 docker start 启动</p><pre class=" language-shell"><code class="language-shell">docker create -it ubuntu:latest</code></pre><h4 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h4><pre class=" language-shell"><code class="language-shell">root@ubuntu_server:/home/coderluo# docker run ubuntu /bin/echo 'i am coderluo'i am coderluo</code></pre><p>等价于先 docker create 然后 docker start命令</p><p>docker run 需要执行的动作:</p><ol><li>检查本地是否有对应的镜像,不存在就从共有仓库下载;</li><li>利用镜像创建并启动一个容器;</li><li>分配一个文件系统,并在只读的镜像层外面挂载一层可读写层;</li><li>从宿主机配置的网桥接口中桥接一个虚拟接口到容器中；</li><li>分配一个ip给容器；</li><li>执行用户指定的应用程序；</li><li>执行完毕后容器关闭；</li></ol><p>接下来，我们打开一个bash终端，允许用户交互：</p><pre class=" language-shell"><code class="language-shell">docker run -ti ubuntu bash</code></pre><p><strong>-t ：</strong> 选项让Docker分配一个伪终端并绑定到容器的标准输入</p><p><strong>-i ：</strong> 让容器的标准输入保持打开</p><p><strong>使用 exit 可以退出容器，退出后该容器就处于终止状态，因为对应Docker容器来说，当运行的应用退出后，容器也就没有运行的必要了；</strong></p><h4 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h4><p>比较常见的是需要Docker容器在后台以守护态 形式运行。 可以通过添加 <strong>-d</strong> 参数来实现：</p><pre class=" language-shell"><code class="language-shell">$ docker run -d ubuntu sh -c "while true; do echo hello world; sleep 1; done"caedc06b26723ec1aff794a053835d2b0b603702bea8a5bb3a39e97b0adf5654$ docker logs caehello worldhello worldhello worldhello worldhello worldhello world</code></pre><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><pre class=" language-shell"><code class="language-shell">docker stop [-t|--time[=10]]</code></pre><p>它首先会向容器发送SIGTERM信号，等待一段时间后（默认10s）。再发送SIGKILL信号终止容器。</p><p>注意： docker kill 会直接发送SIGKILL 来强行终止容器。</p><pre class=" language-shell"><code class="language-shell">$ docker stop caecae</code></pre><p>当Docker容器中运行的应用终结时，容器也自动终止。例如上面开启的终端容器，通过exit退出终端后，创建的容器也会终止。</p><p>可以使用 <code>docekr ps -a -q</code> 所有状态的容器ID信息。</p><pre class=" language-shell"><code class="language-shell">$ docker ps -a -q90bcf718ad13caedc06b2672$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMEScaedc06b2672        ubuntu              "sh -c 'while true; …"   17 minutes ago      Up About a minute                       epic_swartz$ docker restart caecae$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMEScaedc06b2672        ubuntu              "sh -c 'while true; …"   18 minutes ago      Up 8 seconds                            epic_swartz</code></pre><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>当容器后台启动，用户无法进入容器中，如果需要进入容器进行操作，则可以使用下面方法：</p><h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h4><pre class=" language-shell"><code class="language-shell">$ docker run -idt ubuntub9953944f4cc4a17d09bba846d40eea25523098d188d44484f814132e3a04ae7$ docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESb9953944f4cc        ubuntu              "/bin/bash"         7 seconds ago       Up 5 seconds                            laughing_chatterjee$ docker attach laughing_chatterjeeroot@b9953944f4cc:/# </code></pre><p>缺点：当多个窗口同时attach到同一个容器中，所有窗口同步显示，一个阻塞则全部阻塞。</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>Docker 1.3 版本起引入一个可以直接在容器内执行命令的工具 exec。</p><p>进入之前创建的容器，并启动一个bash：</p><pre class=" language-shell"><code class="language-shell">$ docker exec -ti b99 bashroot@b9953944f4cc:/#</code></pre><h4 id="nsenter"><a href="#nsenter" class="headerlink" title="nsenter"></a>nsenter</h4><p>第三方支持，感兴趣可以自己google，个人感觉和exec差不多</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code></p><ul><li>-f，–force=false 强行终止并删除一个运行中的容器</li><li>-l，–link=false 删除容器的连接，但保留容器</li><li>-v，–volumes=false 删除容器挂载的数据卷</li></ul><pre class=" language-shell"><code class="language-shell">$ docker rm 90b90b$ docker rm b99Error response from daemon: You cannot remove a running container b9953944f4cc4a17d09bba846d40eea25523098d188d44484f814132e3a04ae7. Stop the container before attempting removal or force removechong@L MINGW64 ~$ docker rm -f b99b99</code></pre><h3 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><pre class=" language-shell"><code class="language-shell">docker export CONTAINER</code></pre><pre class=" language-shell"><code class="language-shell">docker export cae &gt; test_for_run.tar</code></pre><p>可以将导出的文件传输到其他机器上，直接通过导入命令实现容器迁移。</p><h4 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h4><p>导出的文件可以使用 docker import 命令导入，成为镜像。</p><pre class=" language-shell"><code class="language-shell">$ cat Desktop/test_for_run.tar | docker import - test/ubuntu:v1.0                                                       sha256:aa9dd6a88eb02d192c0574e1e2df171d0ec686a21048cba9a70fcd9ce3ba7d76$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest/ubuntu         v1.0                aa9dd6a88eb0        11 seconds ago      64.2MB</code></pre><p>这里和前面镜像模块的 docker load 载入镜像的区别是：</p><p>docker import 用来导入一个容器快照到本地镜像库，会丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而 docker load 命令载入镜像文件会保存完成的记录，体积也要大。而且容器快照导入可以重新制定标签等元数据信息。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><blockquote><p>仓库是集中存放镜像的地方</p></blockquote><p>很多人容易搞混仓库和注册服务器。这里说明下，注册服务器和仓库的区别。 </p><p>注册服务器是存放仓库的地方，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像，比如ubuntu是一个仓库，下面有很多不同版本的镜像。他所在的服务器就是注册服务器。</p><h3 id="创建和使用私有仓库"><a href="#创建和使用私有仓库" class="headerlink" title="创建和使用私有仓库"></a>创建和使用私有仓库</h3><h4 id="使用registry镜像创建私有仓库"><a href="#使用registry镜像创建私有仓库" class="headerlink" title="使用registry镜像创建私有仓库"></a>使用registry镜像创建私有仓库</h4><p>可以使用官方提供的registry 镜像 简单搭建一套本地私有仓库环境：</p><pre class=" language-shell"><code class="language-shell">docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry</code></pre><p>参数说明：</p><ul><li>-d，后台运行</li><li>-p，端口映射</li><li>-v，将宿主机的/opt/data/registry 绑定到 /var/lib/registry, 来实现数据存放到本地路径，默认registry容器中存放镜像文件的目录/var/lib/registry</li></ul><p>运行后测试下我们私有仓库中的所有镜像：</p><pre class=" language-shell"><code class="language-shell">$ curl http://仓库宿主机ip:5000/v2/_catalog  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100    20  100    20    0     0     20      0  0:00:01 --:--:--  0:00:01   160{"repositories":[]}</code></pre><p>现在是空的，因为才刚运行，里面没有任何镜像内容。</p><h4 id="管理私有仓库镜像"><a href="#管理私有仓库镜像" class="headerlink" title="管理私有仓库镜像"></a>管理私有仓库镜像</h4><p>在一台测试机上（非仓库机）查看已有镜像，如果当前没有镜像 使用 docker pull 下载即可；</p><ol><li><p>为镜像打标签</p><p>格式为： <code>docker tag IMAGE[:TAG] [REGISTRYHOST/] [USERNAME/] NAME[:TAG]</code></p></li></ol><pre class=" language-shell"><code class="language-shell">docker tag ubuntu:latest 192.168.137.200:5000/ubuntu:v1$ docker imagesREPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE192.168.137.200:5000/ubuntu   v1                  a2a15febcdf3        3 days ago          64.2MB</code></pre><p>192.168.137.200:5000 为私有镜像注册服务器的地址和端口</p><ol start="2"><li>上传到镜像服务器</li></ol><pre class=" language-shell"><code class="language-shell">$ docker push 192.168.137.200:5000/ubuntuThe push refers to repository [192.168.137.200:5000/ubuntu]122be11ab4a2: Pushed7beb13bce073: Pushedf7eae43028b3: Pushed6cebf3abed5f: Pushedv1: digest: sha256:ca013ac5c09f9a9f6db8370c1b759a29fe997d64d6591e9a75b71748858f7da0 size: 1152$ curl http://192.168.137.200:5000/v2/_catalog  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100    28  100    28    0     0     28      0  0:00:01 --:--:--  0:00:01   198{"repositories":["ubuntu"]}</code></pre><p>如上curl命令发现已经可以看到仓库中的镜像了。</p><ol start="3"><li>测试下载镜像</li></ol><pre class=" language-shell"><code class="language-shell">$ docker rmi -f 镜像id  # 删除本地镜像$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE$ docker pull 192.168.137.200:5000/ubuntu:v1 #下载私有仓库镜像v1: Pulling from ubuntu35c102085707: Pull complete251f5509d51d: Pull complete8e829fe70a46: Pull complete6001e1789921: Pull completeDigest: sha256:ca013ac5c09f9a9f6db8370c1b759a29fe997d64d6591e9a75b71748858f7da0Status: Downloaded newer image for 39.108.186.135:5000/ubuntu:v1$ docker images # 查看本地镜像REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE192.168.137.200:5000/ubuntu   v1                  a2a15febcdf3        3 days ago          64.2MB</code></pre><p>列出所有镜像：</p><pre class=" language-shell"><code class="language-shell">$ curl 39.108.186.135:5000/v2/_catalog  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100    28  100    28    0     0     28      0  0:00:01 --:--:--  0:00:01   254{"repositories":["ubuntu"]}</code></pre><p>所有某个镜像的所有tag：</p><pre class=" language-shell"><code class="language-shell">$ curl http://39.108.186.135:5000/v2/ubuntu/tags/list  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100    32  100    32    0     0     32      0  0:00:01 --:--:--  0:00:01   128{"name":"ubuntu","tags":["v1"]}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis源码分析</title>
      <link href="/2019/07/27/java/mybatis-yuan-ma-fen-xi/"/>
      <url>/2019/07/27/java/mybatis-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章我们来深入阅读下Mybatis的源码，希望以后可以对底层框架不那么畏惧，学习框架设计中好的思想；</p></blockquote><h2 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/6sf4i.png" alt=""></p><h3 id="架构流程图"><a href="#架构流程图" class="headerlink" title="架构流程图"></a>架构流程图</h3><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/mwc26.png" alt="架构流程图"></p><p>上面这两幅图来源于网络，不过画的很好，基本说明了Mybatis的架构流程。</p><p>说明：</p><ol><li><p>Mybatis配置文件</p><ul><li><p>SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。</p></li><li><p>Mapper.xml，此文件作为mybatis的sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在 </p></li></ul><p>SqlMapConfig.xml中加载。</p></li><li><p>SqlSessionFactory</p><ul><li>通过mybatis环境等配置信息构造SqlSessionFactory，即会话工厂。</li></ul></li><li><p>SqlSession</p><ul><li>通过会话工厂创建sqlSession即会话，程序员通过sqlsession会话接口对数据库进行增删改查操作。</li></ul></li><li><p>Executor执行器</p><ul><li>mybatis底层自定义了Executor执行器接口来具体操作数据库，Executor接口有两个实现，一个是基本执行器 </li></ul><p>（默认）、一个是缓存执行器，sqlsession底层是通过executor接口操作数据库的。</p></li><li><p>MappedStatement</p><ul><li>它也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个 </li></ul><p>select\insert\update\delete标签对应一个Mapped Statement对象，select\insert\update\delete </p><p>标签的id即是Mapped statement的id。</p><ul><li>Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped </li></ul><p>Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对</p></li></ol><h3 id="调用流程图"><a href="#调用流程图" class="headerlink" title="调用流程图"></a>调用流程图</h3><p><img src="http://media.coderluo.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/bwkyg.png" alt="结构"></p><p><strong>Executor</strong></p><p>​    MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</p><p><strong>StatementHandler</strong></p><p>​    封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集 </p><p>合。</p><p><strong>ParameterHandler</strong></p><p>​    负责对用户传递的参数转换成JDBC Statement 所需要的参数</p><p><strong>ResultSetHandler</strong></p><p>​    负责将JDBC返回的ResultSet结果集对象转换成List类型的集合</p><p><strong>TypeHandler</strong></p><p>​    负责java数据类型和jdbc数据类型之间的映射和转换</p><p><strong>SqlSource</strong></p><p>​    负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回BoundSql表 </p><p>示动态生成的SQL语句以及相应的参数信息</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="加载全局配置文件"><a href="#加载全局配置文件" class="headerlink" title="加载全局配置文件"></a>加载全局配置文件</h3><ul><li>找入口：SqlSessionFactoryBuilder#build方法</li></ul><pre><code>SqlSessionFactoryBuilder#build 构建SqlSessionFactory    XMLConfigBuilder#parse 全局配置文件解析，封装成Configuration对象        #parseConfiguration 从根路径开始解析，加载的信息设置到Configuration对象中            #mapperElement 解析mapper映射文件                XMLMapperBuilder#parse 具体解析mapper映射文件                    SqlSessionFactoryBuilder#build：创建SqlSessionFactory接口的默认实现类</code></pre><ul><li>总结</li></ul><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token punctuation">.</span>SqlSessionFactoryBuilder创建SqlsessionFactory时，需要传入一个Configuration对象。 <span class="token number">2</span><span class="token punctuation">.</span>XMLConfigBuilder对象会去实例化Configuration。 <span class="token number">3</span><span class="token punctuation">.</span>XMLConfigBuilder对象会去初始化Configuration对象。     通过XPathParser去解析全局配置文件，形成Document对象     通过XPathParser去获取指定节点的XNode对象。     解析Xnode对象的信息，然后封装到Configuration对象中</code></pre><ul><li>相关类和接口</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span>SqlSessionFactoryBuilder <span class="token operator">|</span><span class="token operator">--</span>XMLConfigBuilder <span class="token operator">|</span><span class="token operator">--</span>XPathParser <span class="token operator">|</span><span class="token operator">--</span>Configuration</code></pre><h3 id="加载映射配置文件"><a href="#加载映射配置文件" class="headerlink" title="加载映射配置文件"></a>加载映射配置文件</h3><ul><li>找入口：XMLConfigBuilder#mapperElement方法</li></ul><pre class=" language-java"><code class="language-java">XMLConfigBuilder#mapperElement<span class="token operator">:</span>解析全局配置文件中的<span class="token operator">&lt;</span>mappers<span class="token operator">&gt;</span>标签     <span class="token operator">|</span><span class="token operator">--</span>XMLMapperBuilder#构造方法：专门用来解析映射文件的         <span class="token operator">|</span><span class="token operator">--</span>XPathParser#构造方法：             <span class="token operator">|</span><span class="token operator">--</span>XPathParser#<span class="token function">createDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：创建Mapper映射文件对应的Document对象             <span class="token operator">|</span><span class="token operator">--</span>MapperBuilderAssistant#构造方法：用于构建MappedStatement对象的         <span class="token operator">|</span><span class="token operator">--</span>XMLMapperBuilder#<span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：             <span class="token operator">|</span><span class="token operator">--</span>XMLMapperBuilder#configurationElement：专门用来解析mapper映射文件                 <span class="token operator">|</span><span class="token operator">--</span>XMLMapperBuilder#buildStatementFromContext：用来创建MappedStatement对象的                     <span class="token operator">|</span><span class="token operator">--</span>XMLMapperBuilder#buildStatementFromContext                         <span class="token operator">|</span><span class="token operator">--</span>XMLStatementBuilder#构造方法：专门用来解析MappedStatement                         <span class="token operator">|</span><span class="token operator">--</span>XMLStatementBuilder#parseStatementNode<span class="token operator">:</span>                             <span class="token operator">|</span><span class="token operator">--</span>MapperBuilderAssistant#addMappedStatement<span class="token operator">:</span>创建 MappedStatement对象                                 <span class="token operator">|</span><span class="token operator">--</span>MappedStatement<span class="token punctuation">.</span>Builder#构造方法                                 <span class="token operator">|</span><span class="token operator">--</span>MappedStatement<span class="token punctuation">.</span>Builder#build方法：创建MappedStatement对象，并存储 到Configuration对象中</code></pre><ul><li>相关接口和类</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span>XMLConfigBuilder <span class="token operator">|</span><span class="token operator">--</span>XMLMapperBuilder <span class="token operator">|</span><span class="token operator">--</span>XPathParser <span class="token operator">|</span><span class="token operator">--</span>MapperBuilderAssistant <span class="token operator">|</span><span class="token operator">--</span>XMLStatementBuilder <span class="token operator">|</span><span class="token operator">--</span>MappedStatement</code></pre><h3 id="SqlSource创建流程"><a href="#SqlSource创建流程" class="headerlink" title="SqlSource创建流程"></a>SqlSource创建流程</h3><ul><li>找入口：XMLLanguageDriver#createSqlSource</li></ul><pre class=" language-java"><code class="language-java">XMLLanguageDriver#createSqlSource 创建SqlSource，解析SQL，封装SQL语句（出参数绑定）和入参信息​    XMLScriptBuilder 构造函数：初始化动态SQL中的节点处理器集合​        XMLScriptBuilder#parseScriptNode ​            #parseDynamicTags 解析select\insert\ update\delete标签中的SQL语句，最终将解析到的SqlNode封装到MixedSqlNode中的List集合中​            DynamicSqlSource 构造方法：如果SQL中包含$<span class="token punctuation">{</span><span class="token punctuation">}</span>和动态SQL语句，则将SqlNode封装到DynamicSqlSource​            RawSqlSource 构造方法：如果SQL中包含#<span class="token punctuation">{</span><span class="token punctuation">}</span>，则将SqlNode封装到RawSqlSource中，并指定parameterType​                SqlSourceBuilder#parse​                    ParameterMappingTokenHandler 构造方法​                        GenericTokenParser#构造方法<span class="token punctuation">,</span>指定待分析的openToken和closeToken并指定处理器​                            GenericTokenParser#parse 解析#<span class="token punctuation">{</span><span class="token punctuation">}</span>​                                ParameterMappingTokenHandler#handleToken  处理token（#<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">/</span>$<span class="token punctuation">{</span><span class="token punctuation">}</span>）​                                    #buildParameterMapping 创建ParameterMapping对象​                                StaticSqlSource 构造方法，将解析之后的sql信息，封装到StaticSqlSource 对象</code></pre><ul><li>相关类和接口</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span>XMLLanguageDriver <span class="token operator">|</span><span class="token operator">--</span>XMLScriptBuilder <span class="token operator">|</span><span class="token operator">--</span>SqlSource <span class="token operator">|</span><span class="token operator">--</span>SqlSourceBuilder</code></pre><h3 id="创建Mapper代理对象"><a href="#创建Mapper代理对象" class="headerlink" title="创建Mapper代理对象"></a>创建Mapper代理对象</h3><ul><li>找入口：DefaultSqlSession#getMapper</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span>DefaultSqlSession#getMapper：获取Mapper代理对象 ​    <span class="token operator">|</span><span class="token operator">--</span>Configuration#getMapper：获取Mapper代理对象 ​        <span class="token operator">|</span><span class="token operator">--</span>MapperRegistry#getMapper：通过代理对象工厂，获取代理对象 ​            <span class="token operator">|</span><span class="token operator">--</span>MapperProxyFactory#newInstance：调用JDK的动态代理方式，创建Mapper代理</code></pre><h3 id="SqlSession执行主流程"><a href="#SqlSession执行主流程" class="headerlink" title="SqlSession执行主流程"></a>SqlSession执行主流程</h3><ul><li>找入口：DefaultSqlSession#selectList()</li></ul><pre class=" language-java"><code class="language-java">DefaultSqlSession#selectList​    CachingExecutor#query​        BaseExecutor#query 委托给BaseExecutor执行​            #queryFromDatabase​            SimpleExecutor#doQuery  执行查询​                Configuration#newStatementHandler  创建路由功能的StatementHandler，根据MappedStatement中的StatementType​            SimpleExecutor#prepareStatement  设置PreapreStatement 的参数​            BaseExecutor#getConnection 获取数据库连接​                BaseStatementHandler#prepare 创建Statement PrepareStatement、Statement、CallableStatement）​                PreparedStatementHandler#parameterize 设置参数​                PreparedStatementHandler#query 执行SQL语句（已经设置过参数），并且映射结果集​                    com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>PreparedStatement#execute 调用JDBC的api执行Statement​                        DefaultResultSetHandler#handleResultSets  处理结果集</code></pre><ul><li>相关接口和类</li></ul><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span>DefaultSqlSession <span class="token operator">|</span><span class="token operator">--</span>Executor     <span class="token operator">|</span><span class="token operator">--</span>CachingExecutor     <span class="token operator">|</span><span class="token operator">--</span>BaseExecutor     <span class="token operator">|</span><span class="token operator">--</span>SimpleExecutor <span class="token operator">|</span><span class="token operator">--</span>StatementHandler     <span class="token operator">|</span><span class="token operator">--</span>RoutingStatementHandler     <span class="token operator">|</span><span class="token operator">--</span>PreparedStatementHandler <span class="token operator">|</span><span class="token operator">--</span>ResultSetHandler     <span class="token operator">|</span><span class="token operator">--</span>DefaultResultSetHandler </code></pre><p>​                    </p><h3 id="BoundSql获取流程"><a href="#BoundSql获取流程" class="headerlink" title="BoundSql获取流程"></a>BoundSql获取流程</h3><ul><li><strong>找入口：MappedStatement#getBoundSql方法</strong></li></ul><pre class=" language-java"><code class="language-java">MappedStatement#getBoundSql​    DynamicSqlSource#getBoundSql ​        SqlSourceBuilder#parse 执行解析：将带有#<span class="token punctuation">{</span><span class="token punctuation">}</span>的SQL语句进行解析，然后封装到StaticSqlSource中​            GenericTokenParser  #构造方法，指定待分析的openToken和closeToken，并指定处理器​                GenericTokenParser#parse 解析SQL语句，处理openToken和closeToken中的内容 ​                    ParameterMappingTokenHandler#handleToken 处理token（#<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">/</span>$<span class="token punctuation">{</span><span class="token punctuation">}</span>）  ​                        #buildParameterMapping  创建 ParameterMapping对象​                            StaticSqlSource#构造方法 ： 将解析之后的SQL信息，封装到StaticSqlSource<span class="token operator">|</span><span class="token operator">--</span>RawSqlSource#getBoundSql ​    <span class="token operator">|</span><span class="token operator">--</span>StaticSqlSource#getBoundSql ​        <span class="token operator">|</span><span class="token operator">--</span>BoundSql#构造方法：将解析后的sql信息、参数映射信息、入参对象组合到BoundSql对象中 </code></pre><h3 id="参数映射流程"><a href="#参数映射流程" class="headerlink" title="参数映射流程"></a>参数映射流程</h3><ul><li>找入口： 其实就是SqlSession执行流程中的 PreparedStatementHandler#parameterize </li></ul><pre><code>|--PreparedStatementHandler#parameterize：设置PreparedStatement的参数 ​    |--DefaultParameterHandler#setParameters：设置参数 ​        |--BaseTypeHandler#setParameter： ​            |--xxxTypeHandler#setNonNullParameter:调用PreparedStatement的setxxx方法</code></pre><h3 id="处理结果集"><a href="#处理结果集" class="headerlink" title="处理结果集"></a>处理结果集</h3><ul><li>找入口：其实就是SqlSession执行流程中的 DefaultResultSetHandler#handleResultSets</li></ul><pre><code>|--DefaultResultSetHandler#handleResultSets ​    |--DefaultResultSetHandler#handleResultSet ​        |--DefaultResultSetHandler#handleRowValues ​            |--DefaultResultSetHandler#handleRowValuesForSimpleResultMap ​                |--DefaultResultSetHandler#getRowValue ​                    |--DefaultResultSetHandler#createResultObject：创建映射结果对象 ​                    |--DefaultResultSetHandler#applyAutomaticMappings ​                    |--DefaultResultSetHandler#applyPropertyMappings </code></pre><p>基本上Mybatis的流程就是这样了，其中还有很多实现细节暂时看不太懂。 我认为学习框架源码分为两步：</p><ol><li>抓住主线，掌握框架的原理和流程；</li><li>理解了处理思路之后，再去理解面向对象思想和设计模式的用法；</li></ol><p>目前第一步尚有问题，需要多走几遍源码，加深下理解，一起加油~~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程堆栈分析</title>
      <link href="/2017/12/26/java/java-xian-cheng-dui-zhan-fen-xi/"/>
      <url>/2017/12/26/java/java-xian-cheng-dui-zhan-fen-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不知觉间工作已有一年了，闲下来的时候总会思考下，作为一名Java程序员，不能一直停留在开发业务使用框架上面。老话说得好，机会是留给有准备的人的，因此，开始计划看一些Java底层一点的东西，尝试开始在学习的过程中写博客，希望和大家一起交流学习。</p></blockquote><p>写在前面： 线程堆栈应该是多线程类应用程序非功能问题定位的最有效手段，可以说是杀手锏。线程堆栈最擅长与分析如下类型问题：</p><ul><li>系统无缘无故CPU过高。</li><li>系统挂起，无响应。</li><li>系统运行越来越慢。</li><li>性能瓶颈（如无法充分利用CPU等）</li><li>线程死锁、死循环，饿死等。</li><li>由于线程数量太多导致系统失败（如无法创建线程等）。</li></ul><h2 id="如何解读线程堆栈"><a href="#如何解读线程堆栈" class="headerlink" title="如何解读线程堆栈"></a>如何解读线程堆栈</h2><p>如下面一段Java源代码程序：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>ccgogoing<span class="token punctuation">.</span>study<span class="token punctuation">.</span>stacktrace<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * @Author: LuoChong400 * @Description: 测试线程 * @Date: Create in 07:27 PM 2017/12/08 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTest</span> <span class="token punctuation">{</span>        Object obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object obj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//为了打印堆栈，该函数堆栈分析不退出</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>            MyTest aa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            aa<span class="token punctuation">.</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>在Idea 中运行该程序，然后按下CTRL+BREAK键，打印出线程堆栈信息如下：</p><pre class=" language-java"><code class="language-java">Full thread dump Java <span class="token function">HotSpot</span><span class="token punctuation">(</span>TM<span class="token punctuation">)</span> <span class="token number">64</span><span class="token operator">-</span>Bit Server <span class="token function">VM</span> <span class="token punctuation">(</span><span class="token number">24.79</span><span class="token operator">-</span>b02 mixed mode<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"Service Thread"</span> daemon prio<span class="token operator">=</span><span class="token number">6</span> tid<span class="token operator">=</span><span class="token number">0x000000000c53b000</span> nid<span class="token operator">=</span><span class="token number">0xca58</span> runnable <span class="token punctuation">[</span><span class="token number">0x0000000000000000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> RUNNABLE<span class="token string">"C2 CompilerThread1"</span> daemon prio<span class="token operator">=</span><span class="token number">10</span> tid<span class="token operator">=</span><span class="token number">0x000000000c516000</span> nid<span class="token operator">=</span><span class="token number">0xd390</span> waiting on condition <span class="token punctuation">[</span><span class="token number">0x0000000000000000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> RUNNABLE<span class="token string">"C2 CompilerThread0"</span> daemon prio<span class="token operator">=</span><span class="token number">10</span> tid<span class="token operator">=</span><span class="token number">0x000000000c515000</span> nid<span class="token operator">=</span><span class="token number">0xcbac</span> waiting on condition <span class="token punctuation">[</span><span class="token number">0x0000000000000000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> RUNNABLE<span class="token string">"Monitor Ctrl-Break"</span> daemon prio<span class="token operator">=</span><span class="token number">6</span> tid<span class="token operator">=</span><span class="token number">0x000000000c514000</span> nid<span class="token operator">=</span><span class="token number">0xd148</span> runnable <span class="token punctuation">[</span><span class="token number">0x000000000caee000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> RUNNABLE    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>SocketInputStream<span class="token punctuation">.</span><span class="token function">socketRead0</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>SocketInputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>SocketInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">152</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>SocketInputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>SocketInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">122</span><span class="token punctuation">)</span>    at sun<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>cs<span class="token punctuation">.</span>StreamDecoder<span class="token punctuation">.</span><span class="token function">readBytes</span><span class="token punctuation">(</span>StreamDecoder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">283</span><span class="token punctuation">)</span>    at sun<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>cs<span class="token punctuation">.</span>StreamDecoder<span class="token punctuation">.</span><span class="token function">implRead</span><span class="token punctuation">(</span>StreamDecoder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">325</span><span class="token punctuation">)</span>    at sun<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>cs<span class="token punctuation">.</span>StreamDecoder<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>StreamDecoder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">177</span><span class="token punctuation">)</span>    <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x00000000d7858b50</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>InputStreamReader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">184</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>BufferedReader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">154</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span>BufferedReader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">317</span><span class="token punctuation">)</span>    <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x00000000d7858b50</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span>BufferedReader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">382</span><span class="token punctuation">)</span>    at com<span class="token punctuation">.</span>intellij<span class="token punctuation">.</span>rt<span class="token punctuation">.</span>execution<span class="token punctuation">.</span>application<span class="token punctuation">.</span>AppMainV2$<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>AppMainV2<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token string">"Attach Listener"</span> daemon prio<span class="token operator">=</span><span class="token number">10</span> tid<span class="token operator">=</span><span class="token number">0x000000000ad4a000</span> nid<span class="token operator">=</span><span class="token number">0xd24c</span> runnable <span class="token punctuation">[</span><span class="token number">0x0000000000000000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> RUNNABLE<span class="token string">"Signal Dispatcher"</span> daemon prio<span class="token operator">=</span><span class="token number">10</span> tid<span class="token operator">=</span><span class="token number">0x000000000c1a8800</span> nid<span class="token operator">=</span><span class="token number">0xd200</span> waiting on condition <span class="token punctuation">[</span><span class="token number">0x0000000000000000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> RUNNABLE<span class="token string">"Finalizer"</span> daemon prio<span class="token operator">=</span><span class="token number">8</span> tid<span class="token operator">=</span><span class="token number">0x000000000ace6000</span> nid<span class="token operator">=</span><span class="token number">0xcd74</span> in Object<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0x000000000c13f000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> <span class="token function">WAITING</span> <span class="token punctuation">(</span>on object monitor<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    <span class="token operator">-</span> waiting on <span class="token operator">&lt;</span><span class="token number">0x00000000d7284858</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>ReferenceQueue$Lock<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>ReferenceQueue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ReferenceQueue<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">135</span><span class="token punctuation">)</span>    <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x00000000d7284858</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>ReferenceQueue$Lock<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>ReferenceQueue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ReferenceQueue<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">151</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>Finalizer$FinalizerThread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Finalizer<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">209</span><span class="token punctuation">)</span><span class="token string">"Reference Handler"</span> daemon prio<span class="token operator">=</span><span class="token number">10</span> tid<span class="token operator">=</span><span class="token number">0x000000000ace4800</span> nid<span class="token operator">=</span><span class="token number">0xce34</span> in Object<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0x000000000bf4f000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> <span class="token function">WAITING</span> <span class="token punctuation">(</span>on object monitor<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    <span class="token operator">-</span> waiting on <span class="token operator">&lt;</span><span class="token number">0x00000000d7284470</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>Reference$Lock<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">503</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>Reference$ReferenceHandler<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Reference<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">133</span><span class="token punctuation">)</span>    <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x00000000d7284470</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>Reference$Lock<span class="token punctuation">)</span><span class="token string">"main"</span> prio<span class="token operator">=</span><span class="token number">6</span> tid<span class="token operator">=</span><span class="token number">0x000000000238e800</span> nid<span class="token operator">=</span><span class="token number">0xc940</span> runnable <span class="token punctuation">[</span><span class="token number">0x00000000027af000</span><span class="token punctuation">]</span>   java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>State<span class="token operator">:</span> RUNNABLE    at org<span class="token punctuation">.</span>ccgogoing<span class="token punctuation">.</span>study<span class="token punctuation">.</span>stacktrace<span class="token punctuation">.</span>MyTest<span class="token punctuation">.</span><span class="token function">fun2</span><span class="token punctuation">(</span>MyTest<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">)</span>    <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x00000000d77d50c8</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">)</span>    at org<span class="token punctuation">.</span>ccgogoing<span class="token punctuation">.</span>study<span class="token punctuation">.</span>stacktrace<span class="token punctuation">.</span>MyTest<span class="token punctuation">.</span><span class="token function">fun1</span><span class="token punctuation">(</span>MyTest<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">)</span>    <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x00000000d77d50b8</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">)</span>    at org<span class="token punctuation">.</span>ccgogoing<span class="token punctuation">.</span>study<span class="token punctuation">.</span>stacktrace<span class="token punctuation">.</span>MyTest<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>MyTest<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">29</span><span class="token punctuation">)</span><span class="token string">"VM Thread"</span> prio<span class="token operator">=</span><span class="token number">10</span> tid<span class="token operator">=</span><span class="token number">0x000000000ace1000</span> nid<span class="token operator">=</span><span class="token number">0xd0a8</span> runnable <span class="token string">"GC task thread#0 (ParallelGC)"</span> prio<span class="token operator">=</span><span class="token number">6</span> tid<span class="token operator">=</span><span class="token number">0x00000000023a4000</span> nid<span class="token operator">=</span><span class="token number">0xd398</span> runnable <span class="token string">"GC task thread#1 (ParallelGC)"</span> prio<span class="token operator">=</span><span class="token number">6</span> tid<span class="token operator">=</span><span class="token number">0x00000000023a5800</span> nid<span class="token operator">=</span><span class="token number">0xcc20</span> runnable <span class="token string">"GC task thread#2 (ParallelGC)"</span> prio<span class="token operator">=</span><span class="token number">6</span> tid<span class="token operator">=</span><span class="token number">0x00000000023a7000</span> nid<span class="token operator">=</span><span class="token number">0xb914</span> runnable <span class="token string">"GC task thread#3 (ParallelGC)"</span> prio<span class="token operator">=</span><span class="token number">6</span> tid<span class="token operator">=</span><span class="token number">0x00000000023a9000</span> nid<span class="token operator">=</span><span class="token number">0xd088</span> runnable <span class="token string">"VM Periodic Task Thread"</span> prio<span class="token operator">=</span><span class="token number">10</span> tid<span class="token operator">=</span><span class="token number">0x000000000c53f000</span> nid<span class="token operator">=</span><span class="token number">0xc1b4</span> waiting on condition JNI global references<span class="token operator">:</span> <span class="token number">138</span>Heap PSYoungGen      total 36864K<span class="token punctuation">,</span> used 6376K <span class="token punctuation">[</span><span class="token number">0x00000000d7280000</span><span class="token punctuation">,</span> <span class="token number">0x00000000d9b80000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>  eden space 31744K<span class="token punctuation">,</span> <span class="token number">20</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000d7280000</span><span class="token punctuation">,</span><span class="token number">0x00000000d78ba0d0</span><span class="token punctuation">,</span><span class="token number">0x00000000d9180000</span><span class="token punctuation">)</span>  from space 5120K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000d9680000</span><span class="token punctuation">,</span><span class="token number">0x00000000d9680000</span><span class="token punctuation">,</span><span class="token number">0x00000000d9b80000</span><span class="token punctuation">)</span>  to   space 5120K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000d9180000</span><span class="token punctuation">,</span><span class="token number">0x00000000d9180000</span><span class="token punctuation">,</span><span class="token number">0x00000000d9680000</span><span class="token punctuation">)</span> ParOldGen       total 83456K<span class="token punctuation">,</span> used 0K <span class="token punctuation">[</span><span class="token number">0x0000000085800000</span><span class="token punctuation">,</span> <span class="token number">0x000000008a980000</span><span class="token punctuation">,</span> <span class="token number">0x00000000d7280000</span><span class="token punctuation">)</span>  object space 83456K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x0000000085800000</span><span class="token punctuation">,</span><span class="token number">0x0000000085800000</span><span class="token punctuation">,</span><span class="token number">0x000000008a980000</span><span class="token punctuation">)</span> PSPermGen       total 21504K<span class="token punctuation">,</span> used 3300K <span class="token punctuation">[</span><span class="token number">0x0000000080600000</span><span class="token punctuation">,</span> <span class="token number">0x0000000081b00000</span><span class="token punctuation">,</span> <span class="token number">0x0000000085800000</span><span class="token punctuation">)</span>  object space 21504K<span class="token punctuation">,</span> <span class="token number">15</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x0000000080600000</span><span class="token punctuation">,</span><span class="token number">0x0000000080939290</span><span class="token punctuation">,</span><span class="token number">0x0000000081b00000</span><span class="token punctuation">)</span></code></pre><p>在上面这段堆栈输出中，可以看到有很多后台线程和main线程，其中只有main线程属于Java用户线程，其他几个都是虚拟机自动创建的，我们分析的过程中，只关心用户线程即可。</p><p>从上面的main线程中可以很直观的看到当前线程的调用上下文，其中一个线程的某一层调用含义如下：</p><pre><code>at MyTest.fun1(MyTest.java:15)    |     |     |              |    |     |     |              +-----当前正在调用的函数所在的源代码文件的行号    |     |     +------------当前正在调用的函数所在的源代码文件    |     +---------------------当前正在调用的方法名    +---------------------------当前正在调用的类名</code></pre><p>另外，堆栈中有：<code>- locked &lt;0x00000000d77d50b8&gt; (a java.lang.Object)</code>语句，表示该线程已经占有柯锁&lt;0x00000000d77d50b8&gt;,尖括号中表示锁ID，这个事系统自动产生的，我们只需要知道每次打印的堆栈，同一个ID表示是同一个锁即可。每一个线程堆栈的第一行含义如下：</p><pre><code>"main" prio=1 tid=0x000000000238e800 nid=0xc940 runnable [0x00000000027af000]    |       |   |                       |           |           |    |       |   |                       |           |           +--线程占用内存地址    |       |   |                       |           +-----------线程的状态    |       |   |                       +----线程对应的本地线程id号    |       |   +-------------------线程id    |       +--------------------------线程优先级    +-------------------------------线程名称其中需要说明的是，线程对应的本地线程id号，是指Java线程所对应的虚拟机中的本地线程。由于Java是解析型语言，执行的实体是Java虚拟机，因此Java语言中的线程是依附于虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码。</code></pre><h3 id="锁的解读"><a href="#锁的解读" class="headerlink" title="锁的解读"></a>锁的解读</h3><p>从上面的线程堆栈看，线程堆栈中包含的直接信息为：线程的个数，每个线程调用的方法堆栈，当前锁的状态。线程的个数可以直接数出来；线程调用的方法堆栈，从下向上看，即表示当前的线程调用了哪个类上的哪个方法。而锁得状态看起来稍微有一点技巧。与锁相关的信息如下：</p><ul><li>当一个线程占有一个锁的时候，线程的堆栈中会打印–locked&lt;0x00000000d77d50c8&gt;</li><li>当一个线程正在等待其它线程释放该锁，线程堆栈中会打印–waiting to lock&lt;0x00000000d77d50c8&gt;</li><li>当一个线程占有一个锁，但又执行到该锁的wait()方法上，线程堆栈中首先打印locked，然后又会打印–waiting on &lt;0x00000000d77d50c8&gt;</li></ul><h3 id="线程状态的解读"><a href="#线程状态的解读" class="headerlink" title="线程状态的解读"></a>线程状态的解读</h3><p>借助线程堆栈，可以分析很多类型的问题，CPU的消耗分析即是线程堆栈分析的一个重要内容；</p><p>处于TIMED_WAITING、WAITING状态的线程一定不消耗CPU。处于RUNNABLE的线程，要结合当前代码的性质判断，是否消耗CPU。</p><ul><li>如果是纯Java运算代码，则消耗CPU。</li><li>如果是网络IO，很少消耗CPU。</li><li>如果是本地代码，要结合本地代码的性质判断（可以通过pstack、gstack获取本地线程堆栈），如果是纯运算代码，则消耗CPU，如果被挂起，则不消耗CPU，如果是IO，则不怎么消耗CPU。</li></ul><h3 id="如何借助线程堆栈分析问题"><a href="#如何借助线程堆栈分析问题" class="headerlink" title="如何借助线程堆栈分析问题"></a>如何借助线程堆栈分析问题</h3><p><strong>线程堆栈在定位如下类型的问题上非常有帮助：</strong></p><ul><li>线程死锁的分析</li><li>Java代码导致的CPU过高分析</li><li>死循环分析</li><li>资源不足分析</li><li>性能瓶颈分析</li></ul><h4 id="线程死锁分析"><a href="#线程死锁分析" class="headerlink" title="线程死锁分析"></a>线程死锁分析</h4><p>死锁的概念就不做过多解释了，不明白的可以去网上查查；</p><p>两个或超过两个线程因为环路的锁依赖关系而形成的锁环，就形成了真正的死锁，如下为死锁喉打印的堆栈：</p><pre class=" language-java"><code class="language-java">Found one Java<span class="token operator">-</span>level deadlock<span class="token operator">:</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token string">"org.ccgogoing.study.stacktrace.deadlock.TestThread2"</span><span class="token operator">:</span>  waiting to lock monitor <span class="token function">0x000000000a9ad118</span> <span class="token punctuation">(</span>object <span class="token number">0x00000000d77363d0</span><span class="token punctuation">,</span> a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">)</span><span class="token punctuation">,</span>  which is held by <span class="token string">"org.ccgogoing.study.stacktrace.deadlock.TestThread1"</span><span class="token string">"org.ccgogoing.study.stacktrace.deadlock.TestThread1"</span><span class="token operator">:</span>  waiting to lock monitor <span class="token function">0x000000000a9abc78</span> <span class="token punctuation">(</span>object <span class="token number">0x00000000d77363e0</span><span class="token punctuation">,</span> a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">)</span><span class="token punctuation">,</span>  which is held by <span class="token string">"org.ccgogoing.study.stacktrace.deadlock.TestThread2"</span>Java stack information <span class="token keyword">for</span> the threads listed above<span class="token operator">:</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token string">"org.ccgogoing.study.stacktrace.deadlock.TestThread2"</span><span class="token operator">:</span>    at org<span class="token punctuation">.</span>ccgogoing<span class="token punctuation">.</span>study<span class="token punctuation">.</span>stacktrace<span class="token punctuation">.</span>deadlock<span class="token punctuation">.</span>TestThread2<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span>TestThread2<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">35</span><span class="token punctuation">)</span>    <span class="token operator">-</span> waiting to lock <span class="token operator">&lt;</span><span class="token number">0x00000000d77363d0</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">)</span>    <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x00000000d77363e0</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">)</span>    at org<span class="token punctuation">.</span>ccgogoing<span class="token punctuation">.</span>study<span class="token punctuation">.</span>stacktrace<span class="token punctuation">.</span>deadlock<span class="token punctuation">.</span>TestThread2<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>TestThread2<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token string">"org.ccgogoing.study.stacktrace.deadlock.TestThread1"</span><span class="token operator">:</span>    at org<span class="token punctuation">.</span>ccgogoing<span class="token punctuation">.</span>study<span class="token punctuation">.</span>stacktrace<span class="token punctuation">.</span>deadlock<span class="token punctuation">.</span>TestThread1<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span>TestThread1<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">33</span><span class="token punctuation">)</span>    <span class="token operator">-</span> waiting to lock <span class="token operator">&lt;</span><span class="token number">0x00000000d77363e0</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">)</span>    <span class="token operator">-</span> locked <span class="token operator">&lt;</span><span class="token number">0x00000000d77363d0</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token punctuation">)</span>    at org<span class="token punctuation">.</span>ccgogoing<span class="token punctuation">.</span>study<span class="token punctuation">.</span>stacktrace<span class="token punctuation">.</span>deadlock<span class="token punctuation">.</span>TestThread1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>TestThread1<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">)</span>Found <span class="token number">1</span> deadlock<span class="token punctuation">.</span></code></pre><p>从打印的堆栈中我们能看到”Found one Java-level deadlock:”,即如果存在死锁情况,堆栈中会直接给出死锁的分析结果.</p><p>当一组Java线程发生死锁的时候,那么意味着Game Over,这些线程永远得被挂在那里了,永远不可能继续运行下去。当发生死锁的线程在执行系统的关键功能时，那么这个死锁可能会导致整个系统瘫痪，要想恢复系统，临时也是唯一的规避方法是<em>将系统重启。然后赶快去修改导致这个死锁的Bug。</em></p><p>注意：死锁的两个或多个线程是不消耗CPU的，有的人认为CPU100%的使用率是线程死锁导致的，这个说法是完全错误的。死循环，并且在循环中代码都是CPU密集型，才有可能导致CPU的100%使用率，像socket或者数据库等IO操作是不怎么消耗CPU的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程堆栈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
