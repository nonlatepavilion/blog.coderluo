---
title: 'CSAPP-1:计算机系统漫游'
tags:
  - CSAPP
date: 2019-08-30 23:43:26
categories: 操作系统
---

> 本周开始了CSAPP的读书计划，规划已久，终于要开动了。之前自己也零散看过，不得不说这本书有难度都没坚持下去，这次跟着码农翻身小伙伴们一起打卡这本书。



CSAPP这本书不用多说绝对经典中的经典，如果想成为一名知道计算机硬件和软件如何工作，了解其如何影响程序的正确性和性能的程序员，那么一定得看啊。

> 如果能完全理解本书讲解的计算机系统以及它对应用程序的影响，那么恭喜你，你走上了一条为数不多的大牛道路。



在开始之前,我们先看一个最常见的程序:

```c
#include <stdio.h>
int main()
{
    printf("hello,world\n");
    return 0;
}
```



本文就从上面这个最简单的hello程序展开,沿着它的生命周期展开学习.



## 程序的保存格式

上面的hello程序其实就是一个由值 0 和 1 组成的位（即比特）序列，8个位成一组，称为字节。我们输入文本hello.c文件中的字符即用每个字节来表示（大部分计算机系统都是用ASCII标准来表示字符，即把字节转为整数值）。

**总结： 信息=位+上下文**



## 程序是如何运行的



hello程序的诞生使用C语言来编写的，好处是人可以读懂，但是为了在系统上运行，还是得转化为一系列低级的机器语言指令。

在Unix系统上，从源文件到目标文件的转化得靠编译器， 下面记录编译过程：

![](http://media.coderluo.top/计算机系统漫游/49y1m.png)

1. hello.c需要经过预处理器读取系统头文件内容并且插入到程序文本中得到一个新的C程序，一般以.i作为扩展名；
2. 然后编译器将文本文件hello.i 翻译成汇编语言文本文件hello.s
3. 接下来，就该汇编器登场，将汇编语言翻译成机器语言指令，并保存到hello.o文件中，此时它是一个二进制文件了
4. 最后链接阶段，将程序中调用的c标准库的函数合并到我们的hello.o程序中，结果就是一个可执行文件，可以被加载到内存中，由系统执行。



### 系统的硬件组成

要真正了解程序时如何运行的，首先要对系统的硬件组成有一个了解：

1. 总线：贯穿整个系统的电子管道，可以理解为所有的数据设备以及系统之间的数据流转都要接到总线上。

2. I/O设备：系统与外部世界的联系通道；比如键盘、鼠标、磁盘、显示器等；

   所有的I/O设置都要通过一个控制器或者适配器与I/O总线相连；

3. 主存：也就是我们常说的内存，这是一个临时存储设备，在处理器执行程序时，用来存放程序和处理的数据；

4. 处理器：也就是我们常说的CPU，是解释存储在主存中指令的引擎；其核心是一个大小为一个字（定长的字节，根据系统不同确定）的寄存器，称为程序计数器（PC）。在程序运行的过程中，PC都是指向主存中的一条机器语言指令。

   从系统通电开始，直到系统断电，处理器一直在不断的执行PC指向的指令，在更新PC，使其指向下一条指令；

   下面列举几个CPU在指令要求下可能执行的操作：

   - 加载：从主存复制一个字到寄存器，已覆盖原有寄存器的内容；
   - 存储：从寄存器复制一个字到主存的某个位置，以覆盖这个位置的原有值；
   - 操作：把两个寄存器的内容复制到ALU（算数/逻辑单元）,ALU对这两个字做算数运算，并将结果存放到一个寄存器中覆盖原有的内容；
   - 跳转：从指令本身抽取一个字，并将这个字复制到PC中，以覆盖PC中原来的值；

   > 处理器看上去是它的指令集架构的简单实现，但是现代处理器采用非常复杂的机制来加速程序的运行。因此我们在理解的时候要将处理器的**指令集架构** 和处理器的 **微体系结构**分来：指令集架构描述的是每条机器代码指令的效果；微体系结构描述的是处理器的实现；

### 运行程序

当我们在执行 `./hello	` 后，其实发生的过程是：

刚开始，shell程序执行它的指令，等待我们输入一个命令，当我们输入`./hello` 后，shell程序将字符读入寄存器，在把它存放到内存中；

当你在敲回车时，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行文件，将目前文件的代码和数据复制到主存。**注：利用直接存储器（DMA）技术，数据可以不到处理器直接从磁盘到主存。**

一旦加载到内存中，处理器就开始执行程序的main机器指令，这些指令将“hello,world\n” 字符串中字节从主存复制到寄存器文件。再从寄存器文件复制到显示设备，最终展示在屏幕上。

![](http://media.coderluo.top/计算机系统漫游/zyak9.png)



## 高速缓存



​	从上面的例子，我们可以总结出，hello程序经历了从开始在磁盘上，加载时被复制到主存，处理器运行时又从主存复制到处理器，最后又从处理器复制到显示器。

​	这里从我们程序员角度讲，这些复制就是开销，那么问题来了，如何减小开销提高处理器效率呢？？？

从机械原理角度来看，存储设备越大运行越慢；处理器读磁盘比读内存开销大1000万倍，而寄存器文件的读取速度又比内存块几乎100倍，加快处理器的运行速度比加快主存运行速度要容器的多。

​	针对处理器与主存之间的差异，系统设计采用了更小更快的存储设备，称之为高速缓存，存放处理器近期可能会需要的信息。这个其实和我们平时开发程序是一样的，采用多级缓存，存放热点数据，提高系统处理能力。 这里的原理是利用程序具有访问局部区域里的数据和代码的趋势，所以高速缓存中存放了可能经常访问的数据，这样大部分操作就能在告诉缓存中完成。

请看下面的存储器层次的结构，相信你会一目了然：

![](http://media.coderluo.top/计算机系统漫游/zwczg.png)



如图所示，上一层存储器是下一层的高速缓存。



## 操作系统管理硬件

我们写的程序，没有直接访问键盘、显示器、磁盘等硬件，而是依赖操作系统提供的服务，所以可以把操作系统看成是应用程序和硬件之间一层软件。

![](http://media.coderluo.top/计算机系统漫游/84g1c.png)



操作系统有两大功能：

1. 防止硬件被滥用；
2. 对应用程序屏蔽底层复杂而通常又大不相同的硬件设备，提供简单一致的机制；

操作系统通常抽象出几个概念：进程、虚拟内存、文件；

### 进程

进程是操作系统对一个正在运行的应用程序的抽象，一个系统可以同时运行多个进程。

单核处理器一个时刻只能执行一个程序，而目前的多核处理器能同时执行多个程序。无论单核还是多核，一个CPU看上去都是在并发执行多个进程，这是通过处理器在进程间切换来实现的，这种切换被称为 **上下文切换**；

进程之间的切换是由操作系统内核管理的，内核是操作系统常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。 注意，内核不是一个独立的进程，它是系统管理所有进程所用代码和数据结构的集合。



### 线程

一个进程实际上是由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

优点：比进程之间更容易共享数据；一般来讲也比进程更高效；

### 虚拟内存

这是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在单独使用主存，每个进程看到的内存都是一致的，称为虚拟地址空间，如下图所示，地址是从小往上增大的：

![](http://media.coderluo.top/计算机系统漫游/d3sxd.png)



### 文件

文件就是字节序列，所有的I/O设备，甚至网络都可以看成是文件；



### 并发

多核处理器是将多个CPU集成到一个集成电路芯片上。多核处理器组织架构如下：

![](http://media.coderluo.top/计算机系统漫游/sx3es.png)



超线程：称为同时多线程，允许一个CPU同时执行多个并发流的技术。Intel Core i7 处理器可以让每个核执行两个线程。

### 计算机系统中的抽象

在处理里，指令集架构提供了对实际处理器硬件的抽象，使用这个抽象，机器代码表现的好像运行在一个一次只执行一条指令的处理器上。不管底层多复杂精细，哪怕可以并发的执行多条指令，担又总是与那个简单有序的模型保持一致。只要模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。这种抽象思想简直太重要了，在整个计算机科学中也随处可见，比如java类的生命和C语言的函数原型，以及计算机网络的分层。

![](http://media.coderluo.top/计算机系统漫游/i7aak.png)



看了这上面的图可以总结为：

1. 文件是对I/O设置的抽象；
2. 虚拟内存是对主存和磁盘的抽象；
3. 进程是对处理器、主存和I/O设备的抽象；



至此，本章的学习就结束了，主要对计算机系统的组成和程序运行有了大框架的认知，后续继续进行深入学习。
