---
title: CSAPP-3-程序的机器级表示
tags:
  - CSAPP
categories: 操作系统
date: 2019-10-08 23:08:05
author: coderluo
---

> 如果能完全理解计算机系统以及它对应用程序的影响，那么恭喜你，你走上了一条为数不多的大牛道路。本文继前两篇之后继续深入学习计算机系统中程序的机器级表示；如果对之前的文章感兴趣可以点击阅读：

- [《CSAPP-1:计算机系统漫游》](<http://coderluo.top/csapp/csapp-1-ji-suan-ji-xi-tong-man-you/>)
- [《CSAPP-2-信息的表示和处理》](<http://coderluo.top/csapp/csapp-2-xin-xi-de-biao-shi-he-chu-li/>)

> 首先，大家都知道的一点，计算机执行的是机器代码，我们平时写的代码，由编译器基于编码规范、目标机器指令集和操作系统惯例经过一系列阶段生成机器代码。**GCC 这个C语言的编译器以汇编代码的形式产生输出，汇编是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。**

平时我们都是用高级语言编程，C语言，Java更是如此，因为这样高效，并且比熟悉汇编语言的人写出来的代码可能还要好。那么我们为什么要学习底层的机器代码呢，原因不多说了，知其然，当然还要知其所以然！今天就一起来学习高级语言程序代码、汇编代码、机器代码之间的关系，让你理解程序的整个运行过程和看懂汇编代码；



## 涉及概念



- IA32，x86-64的32位前身；

- x86-64 是现代电脑中最常见的处理器的机器语言，Intel 处理器系列俗称 x86；
- 32位的机器只能使用大概4G（2^32字节）的随机访问存储器，当前的64位机器能够使用多大256TB（2^48字节）的内存空间(x86-64中，高16位必须是0)；



## 程序编码

这里主要是要C程序演示，使用gcc调用预处理器扩展源代码，插入所有 #include 命令指定的文件，并扩展所有用 #define 生命指定的宏。其次，编译器生成源文件的汇编代码，接下来汇编器会将汇编代码转化成二进制目标代码文件。目标代码是机器代码的一种，包含所有指令的二进制表示，但还没有填入全局值的地址。最后链接器将目标代码文件与实现库函数（例如 printf ） 的代码合并，并产生最终的可执行代码代码文件。



### 机器级代码

机器级编程，设计两种重要的抽象：

1. 指令集体系结构（ISA），来定义机器级程序的格式和行为，定义了处理器的状态、指令格式，以及每条指令对状态的影响。
2. 程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组，存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来；

**x86-64的机器代码和原始的C代码差别非常大，隐藏了一些处理器的状态：**

- 程序计数器（x86-64中用 %rip 表示），给出将要执行下一条指令的内存中地址。
- 整数寄存器文件，可以储存地址（对应C语言的指针）或整数数据。
- 条件码寄存器，保存着最近执行的算术或逻辑指令的状态信息，可以实现if和while语句。
- 一组向量寄存器，可以存放一个或多个整数或浮点数值。

这里就给出一个重要的概念：

> 程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如 malloc库函数分配的）。

### 代码示例

这里大家主要看下C程序代码是如何转换为机器执行的目标代码的：

```c
long mult2(long,long);
void multstore(long x, long y, long *dest) {
    long t = mult2(x, y );
    *dest = t;
}
```



在命令行使用 -S 选项，就能看到C语言编译器产生的汇编代码(这里只运行编译器产生汇编代码，通常情况下会继续调用汇编器产生目标代码文件)：

`gcc -Og -S mstore.c`

汇编代码文件包含各种声明，这里取出其中对应的机器指令(增加相关注释)：

```assembly
// void mulstore(long x, long y, long *dest)
// x in %rdi,	y in % rsi,	dest in %rdx

multstore:
	pushq	%rbx			save %rbx
	movq	%rdx, %rbx		Copy dest to  %rbx
	call	mult2			Call mult2(x,y)
	movq	%rax, (%rbx)	Store result at *dest
	popq	%rbx			Restore %rbx
	ret						return 
```



上面代码中每一行都对应一条机器指令，比如pushq 指令表示应该将寄存器 %rbx 的内容压入程序栈中。

如果使用：`gcc -Og -c mstore.c` GCC会编译并汇编该代码，产生目标代码文件mstore.o ,它是二进制格式的，所以无法直接查看。

如果要查看机器代码文件的内容，我们可有使用反汇编器（disassembler）：

```assembly
[root@localhost ~]# objdump -d mstore.o 

0000000000000000 <multstore>:
   0:	53                   	push   %rbx							
   1:	48 89 d3             	mov    %rdx,%rbx					
   4:	e8 00 00 00 00       	callq  9 <multstore+0x9>			
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	retq  
```



左边可以看到14个十六进制字节值分成了若干组，每组1~5个字节。每组都是一条指令，左边是等价的汇编语言。



上面我们只是演示了如何生成目标代码文件，可是它依旧不是实际可被机器执行的，需要在运行链接器，而目标代码文件中必须含有一个main 函数，如下 文件 main.c:

```c
#include <stdio.h>

int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %d\n", d);
    return 0;
}

long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```



然后使用如下方法生成可执行文件 prog：

```shell
gcc -Og -o prog main.c mstore.c
```

文件变成了8655个字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来和操作系统交互的代码，我们也反汇编 prog文件：

```assembly
[root@localhost ~]# objdump -d prog 
0000000000400560 <multstore>:
  400560:	53                   	push   %rbx
  400561:	48 89 d3             	mov    %rdx,%rbx
  400564:	e8 ef ff ff ff       	callq  400558 <mult2>
  400569:	48 89 03             	mov    %rax,(%rbx)
  40056c:	5b                   	pop    %rbx
  40056d:	c3                   	retq   
  40056e:	66 90                	xchg   %ax,%ax
```



上面只抽取出这一段（建议大家都实际操作下，大概能看明白整个链接器都干了什么，最后的可执行代码是什么样子的），这段代码与 mstore.c 反汇编产生的代码几乎一模一样，其中**主要的区别是左边列出的地址不同--链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同是链接器填上了 callq 指令调用函数 mult2 需要使用的地址**。



## 访问信息

一个x86-64 的中央处理单元（CPU）包含一组16个存储64位值的 `通用目的寄存器`。它们的名字都以%r开头：

![整数寄存器。所有16个寄存器的低位部分都可以作为字节、字(16位)、双字(32位)和四字(64位)数字来访问](C:\Users\chong\Desktop\公众号\小罗公众号\csapp\chapter3\整数寄存器.png)



### 操作数指示符

> 上面的大多数指令都有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64 中，**源数据值可以是常数或是寄存器或内存种中读取。结果可以存放在寄存器或内存中。**



如上所述，各种不同的操作数可被分为三类：

1. 立即数，用来表示常数值，书写方式为 ‘$’ 后面跟一个标准C表示的整数；
2. 寄存器类型，它表示某个寄存器的内容；
3. 内存引用，根据地址访问某个内存位置；



### 数据传送指令



在机器中最常用的一个指令是将数据从一个位置复制到另一个位置。

下面列出最简单形式的数据传送指令--MOV类：



![简单的数据传送指令](C:\Users\chong\Desktop\公众号\小罗公众号\csapp\chapter3\数据传送指令.png)





x86-64中加了一条限制，即传送指令的两个操作数不能都指向内存位置，也就是将一个值从一个内存位置复制到另一个内存位置需要两条指令：

1. 将源值加载到寄存器中；
2. 将寄存器值写入目的的位置；



### 数据传送示例

下面写了一个数据交换函数，即有C代码，也有GCC 产生的汇编代码，可以查看使用数据传送指令。

C代码：

```c
long exchange(long *xp, long y) 
{
    long x = *xp;
    *xp = y;
    return x;
}
```



汇编代码，已经加了注释：

```assembly
// long exchange(long *xp, long y)
// xp in %rdi, y in %rsi
exchange:
	.cfi_startproc
	movq	(%rdi), %rax	get x at xp. Set as return value
	movq	%rsi, (%rdi)	Store y at xp
	ret						Return

```



关于上面的汇编代码，需要注意两点：

1. 我们看到的C语言所谓的“指针”其实就是地址。间接引用指针就是将指针放在一个寄存器中，然后在内存引用中使用这个寄存器。
2. 像x这样的局部变量通常是保存在寄存器中，而不是内存。访问寄存器比访问内存要快得多。



### 压入和弹出栈数据



栈相信大家都不陌生，它的特性是：后进先出，弹出的值永远是最近被压入而且仍然在栈中的值。在x86-64 中，程序栈存放在内存中某个区域，栈向下增长，栈顶元素的地址就是所有栈中元素地址中最低的。栈指针%rsp保存着栈顶元素的地址。



![入栈和出站指令](C:\Users\chong\Desktop\公众号\小罗公众号\csapp\chapter3\入栈和出站指令.png)



- pushq 指令的功能是把数据压入到栈上
- popq 指令是弹出数据

将一个四字值压入栈中，需要执行两步操作，首先栈指针减8，然后将值写到新的栈顶地址，例如：

指令 pushq %rbp 等价于：

```assembly
subq $8,%rsp	// Decrement stack pointer
movq %rbp,(%rsp)	// Store %rbp on stack
```



下面的图更能说明执行压栈和弹出时，是如何执行指令的：

![栈操作说明](C:\Users\chong\Desktop\公众号\小罗公众号\csapp\chapter3\栈操作说明.png)



## 算术和逻辑操作



x86-64定义了一些整数和逻辑操作，大多数操作都分成了指令类，如下图所示：



![整数算术操作](C:\Users\chong\Desktop\公众号\小罗公众号\csapp\chapter3\整数算术操作.png)

这些操作被分为四组： 加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。



### 加载有效地址

`加载有效地址指令 leaq` 实际上是movq 指令的变形。它的指令形式是从内存读取数据到寄存器，但它实际上根本没有引用内存，它不是从指定的位置读入数据，而是将有效地址写入到目的操作数。这条指令可以为后面的内存引用产生指针。而且可以简洁的描述普通的算术操作。例如，如果寄存器%rdx 的值为x，那么指令 leaq7（%rdx，%rdx，4），%rdx将设置寄存器%rdx的值为5x+7。

下面我们写一个C程序，来学习leaq在编译出的代码中的使用，看看下面这个C程序：



```c
long scale(long x, long y, long z) 
{
    long t = x+4*y+12*z;
    return t;
}
```



编译时，该函数的算术运算以三条leaq指令实现，就像右边注释说明的那样：

```assembly
// long scale(long x, long y, long z)
// x in %rdi,y in%rsi, z in %rdx
scale:
	leaq	(%rdi,%rsi,4), %rcx		// x + 4*y
	leaq	(%rdx,%rdx,2), %rax		// z + 2*z = 3*z
	salq	$2, %rax				// 3*z<<2=12*z,左移
	addq	%rcx, %rax 				// x+4*y + 12*z
	ret

```



























































































