---
title: chapter6-网络安全
tags:
  - 网络安全
date: 2019-09-14 15:17:59
categories: 计算机网络

---



计算机网络中的两个节点希望安全通信，需要具有以下的特性

*   **机密性**。这说明通信的内容只有发送方和接收方才能知道，窃听者截获报文后也无法理解报文的内容
*   **报文完整性**。发送方和接收方希望报文在传输过程中没有被篡改
*   **端点鉴别**。发送方和接收方都能确定另一方的确有其声称的身份
*   **运行安全性**。能够连接到互联网的主机，都希望不会因为恶意者的攻击而瘫痪

## 密码学原理

要达到安全通信中的机密性，就需要对传输的报文加密。被加密的报文称为 **明文（plaintext，clear text）**；使用 **加密算法（encryption algorithm）** 可以加密明文得到 **密文（ciphertext）**；在加密的过程中需要使用 **密钥（key）**；如果需要把密文重新转成明文，就需要用到 **解密算法（decryption algorithm）**；类似的，解密算法也需要解密密钥。在对称加密中，加密密钥和解密密钥是相同的；而在公开密钥系统中，加密和解密的密钥是不同的，且加密密钥是公开的

### 凯撒密码

凯撒密码是以罗马共和国执政官尤里乌斯·凯撒的名字命名的一种加密技术，原理非常简单：对于一个明文输入，将明文中的字母替换成另一个字母。每一种替换规则就是一个密钥

凯撒密码有一个重要缺陷，即相同的明文字母对应同一个密文字母，因此可以用统计分析的方式去破解密码。比如英文中字母 e 出现的频率大约是 13%，而字母 t 出现的频率是 19%，而且英文单词 the 出现的概率也特别高，这样就能统计密文中字母或单词出现的频率来估算加密的密钥

如果尝试攻击凯撒密码，根据攻击者所拥有的信息，可以把攻击方法分为下面 3 种

*   **唯密文攻击**：攻击者只知道密文，这时可以使用对字母频率的统计分析来攻击凯撒密码
*   **已知明文攻击**：攻击者知道明文中一定会出现一些单词，根据这些单词的密文来攻击凯撒密码
*   **选择明文攻击**：攻击者能够得到一些明文对应的密文，从而展开攻击。这与已知明文攻击有些类似

针对这几种攻击，后来发展出了 **多码代替密码（polyalphabetic encryption）** 技术，这种技术尝试用多个凯撒密码密钥去加密一段密文

### 块密码

**块密码** 是对称加密的一种方法，它将明文分为 k 比特的块，将每一个块映射为另一个块，映射的结果就是密文，每一种映射就是一个密钥。对于 k 比特的块，共有 `(2^k)!` 种密钥。当 k 的值比较大时（如 k = 64），保存 `(2^k)!` 个映射关系的成本太高了，因此实际应用中会使用函数模拟的方式生成随机排列表，使得输入一个 k 比特的明文得到 k 比特密文，这个函数必须要有一个性质：明文的每一个比特位都能影响输出结果

目前 DES（Data Encryption Standard）、3DES 和 AES（Advanced Encryption Standard）都是块密码

实际上块密码与凯撒密码有些相似的地方，他们都是把明文替换成密文的方式，因此也会具有与凯撒密码相同的弱点，即相同的明文得到相同的密文。消除这个弱点的方式是在加密的过程中引入随机性。

一个可行的方法是：将明文分为 k 比特的明文快，对于每个明文快 mi，产生一个随机的 k 比特块 ri，那么密文 `ci = Ks(mi xor ri)`，其中 xor 是异或操作，Ks 是以 s 为密钥的加密函数。由于每一个明文快对应的随机块 ri 是不一样的，因此相同的明文块会产生不同的密文块

这个方法也有一个问题：传输的数据量变成了原来的两倍。因为现在不仅仅需要传输密文，还需要传输随机块 ri。为了解决这个问题，产生了一种称作 **密码块链接（Cipher Block Chaining，CBC）** 的技术。它的原理是：仅仅产生第一个明文块的随机块，加密得到第一个密文块后，这个密文块就作为下一个明文块的随机块。

## 公开密钥加密

上面的凯撒密码和块密码都是被称为对称加密的技术，这意味着加密方和解密方需要使用同一个密钥来加密和解密。对称加密引入了一个新的问题：双方该如何安全的共享密钥。在现代的计算机网络中，发送方和接收方是无法在线下见面并确定密钥的

为了解决这个问题，一种被称为 **公开密钥加密** 的技术被发明出来。公开密钥加密技术使用两个密钥，一个被称为 **公钥（public key）**，一个被称为 **私钥（private key）**。公钥是公开的，并且每个人都能知道，而私钥需要保密。公开密钥加密算法有这样一个性质：使用公钥加密明文得到密文，可以使用私钥解密；使用私钥加密明文得到密文，可以使用公钥解密。因此当两个人，比如 Bob 和 Alice 想要通信时，Bob 先获取到 Alice 的公钥，使用公钥加密后把密文发送给 Alice，Alice 得到密文后就能用私钥解密得到明文了；同理，Alice 也能获取到 Bob 的公钥并加密明文，Bob 用自己的私钥解密。当攻击者截取到密文后，因为没有私钥，也就不能解密密文了。

公开密钥加密算法需要面临两个问题

1.  攻击者可以使用选择明文攻击。因为公钥和加密算法是众所周知的，攻击者可以用任意明文生成密文，并以此展开攻击，公开密钥加密必须能防止攻击者以猜出私钥
2.  接收方无法得知密文是谁发送的。在共享密钥中，接收方收到密文后就能知道发送方是谁了，因为只有发送方能有密钥去加密。现在因为公钥和加密算法是公开的，任何一个人都能向接收方发送一段密文，因此接收方必须使用其他方法去确定发送方的身份

RSA 是现在比较流行的公开密钥加密算法，它基于的原理是目前没有高效的算法可以对大整数做因数分解。它的工作方式我就不说了，因为我也看不懂

## 报文完整性和数字签名

Bob 在收到一个来自于声称自己是 Alice 的人的报文时，他需要做下面两件事

1.  确定报文确实来自于 Alice
2.  确定报文在传输过程中没有收到篡改

在讨论这两点之前，我们还需要学习有关 **密码散列函数** 的知识

### 密码散列函数

密码散列函数以 m 作为输入，可以得到一个固定长度的输出字符串，而且必须要求找到任意两个不同的报文 x 和 y，计算 H(x) = H(y) 在计算上是不可能的，这也表明，得到散列函数的输出后，反推输入是不可能的。目前常用的散列函数有 MD5、SHA-1

有了散列函数，就能在接收端鉴定报文在传输过程中有没有被篡改了。比如 Alice 向 Bob 发送报文

1.  Alice 和 Bob 之间先生成一个 **鉴别密钥（authentication key）** s
2.  Alice 生成报文 m，使用散列函数计算得到 H(m + s)，H(m+s) 也叫做 **报文鉴别码（Message Authentication Code，MAC）**
3.  Alice 把 m 和 H(m + s) 合并成扩展报文 (m, H(m + s)) 发送给 Bob
4.  Bob 收到扩展报文后，同样去计算 H(m + s)，如果与收到的 MAC 一致，说明报文没有被篡改

鉴别密钥的作用是防止中间人在捕获到报文 m 后，篡改报文并重名生成 H(m)，这样接收方就还是无法确定报文是否被篡改

目前最流行的 MAC 标准是 HMAC

### 数字签名

数字签名是一种同时使用了散列函数和非对称加密的技术。当 Bob 需要对一个报文 m 做签名，他首先用散列函数对报文计算指纹 H(m)，然后用自己的私钥和指纹作为输入，得到的输出就是数字签名。任何人如果想证明 Bob 的确对报文 m 做过签名，只需要先计算报文的指纹，然后使用 Bob 的公钥对签名进行解密，如果得到的指纹和结果是一致的，就说明了 Bob 的确签署了报文

上面的数字签名技术还有一个问题没解决：如果为每个人分配私钥和公钥。这个问题需要由 **认证中心（Certification Authority，CA）** 来负责。CA 为每个需要被认证的实体生成一个证书，证书内有公钥、私钥和拥有者的全局唯一标识符，大家只要信任 CA 就能信赖数字签名技术了

### PGP

PGP 是一个电子邮件加密方案，全称是 Pretty Good Privacy。它融合了 RSA 加密、对称加密、数字签名技术，提供了对电子邮件的机密性、发送方鉴别和保温完整性验证功能，它的基本原理是这样的（假设 Alice 要向 Bob 发送邮件）

1.  Alice 使用散列函数得到报文摘要
2.  Alice 使用自己的私钥加密摘要得到报文签名，将数字签名和报文级联成为新报文
3.  Alice 随机生成一个会话密钥，利用会话密钥加密新报文得到密文，用 Bob 的公钥加密会话密钥
4.  Alice 将报文签名、密文、加密后的会话密钥发送给 Bob

到此 Alice 的工作就结束了。Bob 在接收到 Alice 发来的数据后，做如下操作

1.  Bob 用自己的私钥解密会话密钥
2.  Bob 用会话密钥解密密文，得到报文和数字签名
3.  Bob 使用散列函数得到报文摘要，然后使用自己的公钥解密数字签名，如果两个计算得到的结果相同，说明数据在传输过程中没有被篡改

### SSL

**SSL(Secure Socket Layer)** 相当于是一个提供了安全服务的加强版 TCP，它的第三版本也被称为 **TLS(Transport Layer Security)** 。SSL 差不多是取代 TCP 原有位置的，但是实际上它是一个应用层协议。SSL 的具体原理也很复杂，我这里只列出一些要点

1.  在 SSL 通信的双方（比如 Bob 和 Alice）共使用了 4 个密钥：一个密钥是 Bob 向 Alice 发送数据的会话密钥；一个密钥是 Bob 向 Alice 发送报文完整性检测 MAC 密钥；一个密钥是 Alice 向 Bob 发送数据的会话密钥；一个密钥是 Alice 向 Bob 发送报文完整性检测 MAC 密钥
2.  SSL 将报文数据分成被称为 **记录** 的基本单元，对记录做加密和报文完整性验证。SSL 对记录数据+MAC密钥+记录序号做散列，这样能防止中间人恶意替换记录的顺序

## 防火墙

防火墙是一种软件加上硬件一起实施网络连接管理的工具，可以认为这是一个位于网络边缘的路由器，具有下面的性质

*   所有从内部网络流向外部和从外部流向内部的流量都必须经过防火墙
*   防火墙仅会让允许授权的流量通过
*   防火墙必须足够安全，不能被攻破

防火墙的过滤方式可以分为 3 类：**传统分组过滤器（traditional packet filter）**、**状态过滤器（stateful filter）**、**应用程序网关（application gateway）**

### 分组过滤器

分组过滤器检查所有流经防火墙的数据包，基于事先定下的规则决定是否放行流量。它做出的决定基于下面因素

*   数据报的源地址或目的地址
*   数据报的协议类型：TCP、UDP、ICMP、OSPF 等
*   TCP 或 UDP 的源或目的端口
*   TCP 标志比特：SYN、ACK 等
*   ICMP 报文类型
*   数据报离开和进入网络的不同规则
*   对不同路由器的接口的不同规则

### 状态分组过滤器

前面的分组过滤器只是根据一个分组的数据报决定是否放行，而状态分组过滤器会记录这个分组属于的连接，根据连接的状态决定是否放行分组

简单来说，当内部或者外部用户发起 TCP 连接时，都必须经历 3 次握手（ SYN、SYNACK、ACK），防火墙可以探测到这些报文，然后在自己的数据库包保存这个 TCP 连接信息，当一个数据报来到防火墙时，防火墙在自己的数据库中检索到连接信息，然后根据既定的规则决定是否放行

### 应用程序网关

上面的两个过滤器都是应用于非应用层的数据报，有时候报文的认证信息存在于应用层中，这时候需要使用到 **应用程序网关（applicatin gateway）**。它不仅仅会检查 TCP 或者 UDP 数据报，还会检查应用层数据，以决定流量是否放行

### 入侵检测系统

**入侵检测系统（Intrusion Detection System，IDS）** 相当于是一个探针，安装在网络路径上，他会检测所有的流经自身的流量，在其中检测是否存在可疑流量，在必要的时候向网络管理员发送警告

在一个网络中可能会部署多个 IDS，因为 IDS 对所有流量执行检测，需要大量的计算量，部署多个 IDS 能减轻每个 IDS 的负担

IDS 使用了 **基于特征的系统（signature-based system）** 或 **基于异常的系统（anomaly-based system）**。基于特征的 IDS 有一个攻击的特征数据库，当流经的流量与某种攻击相似时（源端口相同、或者协议的某些字段值相同），它就会发出警告。基于特征的 IDS 的缺点是不能检测出新的攻击

基于异常的 IDS 观察流经自身的流量，统计不同协议的分组的数量，当某种分组的数量异常升高时，他就判定网络中可能存在攻击行为。它的优点就是能够检测出新的攻击形式

Snort 是一个开源的 IDS 实现，在全球大量部署，当一种新的攻击方式出现时，Snort 社区可能会在几小时内编写出应对规则，并供全球范围内的网络管理员下载和部署